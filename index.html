<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>archive.aero - Historical Aeronautical Chart Viewer</title>
  <meta name="description"
    content="Explore historical aeronautical charts and sectional maps. View how aviation charts have evolved over time with AeroMap's interactive timeline viewer." />
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚úàÔ∏è</text></svg>" />

  <!-- Preload critical resources -->
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://data.archive.aero" crossorigin>
  <link rel="preconnect" href="https://basemaps.cartocdn.com" crossorigin>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="styles.css" />

  <!-- Privacy-friendly analytics by Plausible -->
  <script async src="https://plausible.io/js/pa-m9DzDEgB7Ebb2zKdbBaMF.js"></script>
  <script>
    window.plausible = window.plausible || function () { (plausible.q = plausible.q || []).push(arguments) }, plausible.init = plausible.init || function (i) { plausible.o = i || {} };
    plausible.init()
  </script>

</head>

<body>

  <!-- Loading Splash Screen -->
  <div class="loading-splash" id="loadingSplash" role="status" aria-live="polite">
    <div class="loading-logo" aria-hidden="true">‚úàÔ∏è</div>
    <div class="loading-title">archive.aero</div>
    <div class="loading-progress">
      <div class="loading-progress-bar" id="loadingProgressBar"></div>
    </div>
    <div class="loading-status" id="loadingStatus">Initializing...</div>
  </div>

  <!-- Header Bar -->
  <div class="header-bar">
    <div class="header-content">
      <a href="/" class="site-logo">
        ‚úàÔ∏è archive.aero
      </a>
      <span class="site-tagline">Historical Aviation Charts</span>
      <a href="https://buymeacoffee.com/ryanhemenway" target="_blank" rel="noopener" class="donate-btn" title="Support this project">
        ‚òï Support
      </a>
    </div>

    <div class="header-actions">
      <!-- Map Tools -->
      <div class="btn-group">
        <button class="icon-btn" id="mapToolsBtn" title="Map Tools" aria-label="Open map tools panel">üõ†Ô∏è</button>
        <button class="icon-btn" id="chartInfoBtn" title="Chart Info" aria-label="View chart information">üìã</button>
      </div>
      <div class="btn-separator"></div>
      <!-- View Controls -->
      <div class="btn-group">
        <button class="icon-btn" id="shareBtn" title="Share (S)" aria-label="Share current view">üîó</button>
        <button class="icon-btn" id="fullscreenBtn" title="Fullscreen (F)">‚õ∂</button>
        <button class="icon-btn" id="helpBtn" title="Keyboard Shortcuts (?)">?</button>
      </div>
      <div class="btn-separator"></div>
      <!-- External Links -->
      <div class="btn-group">
        <a href="https://ryanhemenway.com" target="_blank" rel="noopener" class="icon-btn" title="About Me">üë®‚Äç‚úàÔ∏è</a>
        <a href="https://github.com/hemenway/AeroMap" target="_blank" rel="noopener" class="icon-btn" title="View on GitHub">
          <svg width="18" height="18" viewBox="0 0 16 16" fill="currentColor">
            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
          </svg>
        </a>
      </div>
    </div>
  </div>

  <!-- Opacity Control -->
  <div class="opacity-control" id="opacityControl">
    <h4>Chart Opacity</h4>
    <input type="range" class="opacity-slider" id="opacitySlider" min="0" max="100" value="100">
    <div class="opacity-value"><span id="opacityValue">100</span>%</div>
  </div>

  <!-- Map Tools Panel -->
  <div class="map-tools-panel" id="mapToolsPanel">
    <h4>üõ†Ô∏è Map Tools</h4>

    <div class="tool-section">
      <span class="tool-label">Chart Opacity</span>
      <div class="tool-slider-container">
        <input type="range" class="tool-slider" id="toolOpacitySlider" min="0" max="100" value="100">
        <div class="tool-value"><span id="toolOpacityValue">100</span>%</div>
      </div>
    </div>

    <div class="tool-section">
      <span class="tool-label">My Location</span>
      <button class="tool-button" id="locateBtn">
        <span>Center Map</span>
        <span>üß≠</span>
      </button>
    </div>

    <div class="tool-section">
      <span class="tool-label">Split View</span>
      <button class="tool-button" id="toolCompareBtn">
        <span>Side-by-Side</span>
        <span>‚ó´</span>
      </button>
    </div>

    <div class="tool-section">
      <span class="tool-label">History Range</span>
      <div class="tool-slider-container">
        <input type="number" class="tool-input" id="historyDaysInput" min="0" max="3650" value="0" placeholder="Days">
        <span class="tool-unit">days back</span>
      </div>
      <div class="tool-hint" id="historyHint">Set to 0 for single map</div>
    </div>
  </div>

  <!-- Share Panel -->
  <div class="share-panel" id="sharePanel" role="dialog" aria-labelledby="sharePanelTitle">
    <h4 id="sharePanelTitle">Share This View</h4>
    <div class="share-url-box">
      <input type="text" class="share-url" id="shareUrl" readonly aria-label="Share URL">
      <button class="copy-btn" id="copyBtn">Copy</button>
    </div>
    <div class="share-info">Share your current timeframe and map position</div>
  </div>

  <!-- Chart Info Panel -->
  <div class="chart-info-panel" id="chartInfoPanel" role="dialog" aria-labelledby="chartInfoTitle">
    <h4 id="chartInfoTitle">üìã Chart Information</h4>
    <div class="chart-info-row">
      <span class="chart-info-label">Date</span>
      <span class="chart-info-value" id="chartInfoDate">‚Äî</span>
    </div>
    <div class="chart-info-row">
      <span class="chart-info-label">Type</span>
      <span class="chart-info-value"><span class="chart-badge sectional">Sectional</span></span>
    </div>
    <div class="chart-info-row">
      <span class="chart-info-label">Format</span>
      <span class="chart-info-value">PMTiles / WebP</span>
    </div>
    <div class="chart-info-row">
      <span class="chart-info-label">Total Charts</span>
      <span class="chart-info-value" id="chartInfoTotal">‚Äî</span>
    </div>
    <div class="chart-info-row">
      <span class="chart-info-label">Status</span>
      <span class="chart-badge historical">Historical Only</span>
    </div>
    <div class="chart-info-row">
      <span class="chart-info-label">Zoom Level</span>
      <span class="chart-info-value" id="chartInfoZoom">‚Äî</span>
    </div>
  </div>

  <!-- Keyboard Shortcuts Overlay -->
  <div class="shortcuts-overlay" id="shortcutsOverlay">
    <div class="shortcuts-content">
      <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
      <div class="shortcut-item">
        <span class="shortcut-desc">Next timeframe</span>
        <span class="shortcut-key">‚Üí</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Previous timeframe</span>
        <span class="shortcut-key">‚Üê</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Play/Pause animation</span>
        <span class="shortcut-key">Space</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Toggle fullscreen</span>
        <span class="shortcut-key">F</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Share current view</span>
        <span class="shortcut-key">S</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Show this help</span>
        <span class="shortcut-key">?</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Close overlay</span>
        <span class="shortcut-key">Esc</span>
      </div>
      <button class="close-shortcuts" id="closeShortcuts">Close</button>
    </div>
  </div>

  <!-- Warning Banner -->
  <div class="warning-overlay" id="warningOverlay">
    <div class="warning-modal">
      <span class="warning-icon">‚ö†Ô∏è</span>
      <p class="warning-text">
        Historical charts only. Do not use for navigation.
      </p>
    </div>
  </div>

  <div id="map"></div>
  <div id="map2"></div>

  <!-- Sources Link -->
  <a href="sources.html" class="sources-link">Sources & Attribution</a>

  <div class="map2-controls">
    <input type="date" id="map2TimeSelect" class="time-select" aria-label="Select comparison timeframe">
  </div>

  <div class="toast" id="toast"></div>

  <div class="ui-layer">
    <div class="controls-card">
      <div class="jog-controls">
        <button class="btn-nav" id="prevBtn" title="Previous Timeframe (‚Üê)" aria-label="Previous timeframe">‚Üê</button>
        <button class="btn-play" id="playBtn" title="Play/Pause (Space)" aria-label="Play or pause animation">‚ñ∂</button>
        <button class="btn-nav" id="nextBtn" title="Next Timeframe (‚Üí)" aria-label="Next timeframe">‚Üí</button>
      </div>

      <div class="speed-control" role="group" aria-label="Animation speed">
        <button class="speed-btn" data-speed="0.5" title="Half speed">¬Ω√ó</button>
        <button class="speed-btn active" data-speed="1" title="Normal speed" aria-pressed="true">1√ó</button>
        <button class="speed-btn" data-speed="2" title="Double speed">2√ó</button>
      </div>

      <div class="loader" id="loader" role="status" aria-label="Loading"></div>

      <div class="timeline-track-wrapper" id="trackWrapper">
        <div class="timeline-track">
          <div class="timeline-progress" id="progress"></div>
          <div id="ticksContainer"></div>
          <div class="handle" id="handle"></div>
        </div>
      </div>

      <div class="info-panel">
        <input type="date" id="timeSelect" class="time-select" aria-label="Select timeframe">
        <div class="label-sub" id="lblRange">Timeline</div>
      </div>
    </div>


  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>

  <script>
    // Guard against Leaflet tile callbacks firing after a layer was removed
    if (L && L.TileLayer && L.TileLayer.prototype._tileReady) {
      const originalTileReady = L.TileLayer.prototype._tileReady;
      L.TileLayer.prototype._tileReady = function(error, tile) {
        if (!this._map) return;
        return originalTileReady.call(this, error, tile);
      };
    }

    /** CONFIGURATION **/
    const CONFIG = {
      baseUrl: 'https://data.archive.aero/sectionals/pmtiles/',
      csvUrl: 'dates.csv', // Dynamic Source
      initialView: { center: [32.7767, -96.7970], zoom: 10 },
      frames: [] // Will be populated dynamically
    };

    /** UTILITIES **/
    const Utils = {
      buildPMTilesUrl: (date, customUrl) => {
        if (customUrl) return customUrl;
        return `${CONFIG.baseUrl}${date}.pmtiles`;
      },
      toast: (msg, duration = 3000) => {
        const el = document.getElementById('toast');
        if (el) {
          el.textContent = msg;
          el.classList.add('visible');
          setTimeout(() => el.classList.remove('visible'), duration);
        }
      },
      formatDateId: (dateStr) => {
        try {
          const [y, m, d] = dateStr.split('-').map(Number);
          const date = new Date(y, m - 1, d);
          return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
        } catch (e) {
          return dateStr;
        }
      },
      toggleFullscreen: () => {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(err => {
            Utils.toast(`Error entering fullscreen: ${err.message}`);
          });
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        }
      },
      debounce: (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
    };

    /** DATA LOADER **/
    async function loadData() {
      return new Promise((resolve, reject) => {
        Papa.parse(CONFIG.csvUrl, {
          download: true,
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            try {
              const frames = [];
              results.data.forEach(row => {
                if (!row.date_iso || row.date_iso === '?') return;
                frames.push({
                  id: Utils.formatDateId(row.date_iso),
                  date: row.date_iso,
                  url: row.url || null
                });
              });
              CONFIG.frames = frames.sort((a, b) => {
                return new Date(a.date) - new Date(b.date);
              });
              resolve();
            } catch (e) {
              console.error("Data processing error", e);
              Utils.toast("Error processing CSV data");
              reject(e);
            }
          },
          error: (err) => {
            console.error("CSV Load Error", err);
            Utils.toast("Failed to load timeline data");
            reject(err);
          }
        });
      });
    }

    /** MAP CONTROLLER **/
    class MapController {
      constructor(mapId) {
        this.map = L.map(mapId, {
          zoomControl: false,
          fadeAnimation: true,
          zoomAnimation: true,
          attributionControl: true,
          zoomSnap: 0.25,
          zoomDelta: 0.5,
          wheelPxPerZoomLevel: 120
        }).setView(CONFIG.initialView.center, CONFIG.initialView.zoom);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 22, maxNativeZoom: 20, opacity: 1, zIndex: 1,
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &middot; &copy; <a href="https://carto.com/attributions">CARTO</a>'
        }).addTo(this.map);

        L.control.zoom({ position: 'topright' }).addTo(this.map);

        this.cache = {};
        this.activeLayers = [];
        this.pmtilesInstances = {}; // Cache for PMTiles instances
        this.requestCounter = 0; // Track most recent frame request

        // Debounced version of showFrame for timeline scrubbing
        this.showFrameDebounced = Utils.debounce(this.showFrame.bind(this), 250);
      }

      getLayerData(date, customUrl) {
        if (this.cache[date]) return this.cache[date];

        const pmtilesUrl = Utils.buildPMTilesUrl(date, customUrl);

        // Create a PMTiles-backed raster tile layer
        // Using the pmtiles library to create a tile source
        const p = new pmtiles.PMTiles(pmtilesUrl);
        this.pmtilesInstances[date] = p;

        // Create a Leaflet tile layer that fetches from PMTiles
        const layer = L.tileLayer('', {
          minZoom: 0,
          maxZoom: 22,
          minNativeZoom: 0,
          maxNativeZoom: 11,  // Tiles generated up to zoom 11, Leaflet will scale beyond
          tileSize: 256,
          opacity: 0,
          zIndex: 10,
          keepBuffer: 2,
          updateWhenIdle: true,
          updateWhenZooming: false
        });

        // Override the getTileUrl method to use PMTiles
        const maxNativeZoom = 11;
        layer.createTile = function(coords, done) {
          const tile = document.createElement('img');
          tile.alt = '';
          tile.setAttribute('role', 'presentation');

          // Handle overzoom - fetch tile from maxNativeZoom and let Leaflet scale it
          let z = coords.z;
          let x = coords.x;
          let y = coords.y;

          if (z > maxNativeZoom) {
            const zoomDiff = z - maxNativeZoom;
            z = maxNativeZoom;
            x = Math.floor(x / Math.pow(2, zoomDiff));
            y = Math.floor(y / Math.pow(2, zoomDiff));
          }

          p.getZxy(z, x, y).then(result => {
            // If layer was removed before data arrived, abort
            if (!layer._map) return;

            if (result && result.data) {
              const blob = new Blob([result.data], { type: 'image/webp' });
              tile.src = URL.createObjectURL(blob);
              tile.onload = () => {
                URL.revokeObjectURL(tile.src);
                // Skip callback if layer is no longer on a map to avoid Leaflet null _map errors
                if (!layer._map) return;
                done(null, tile);
              };
              tile.onerror = () => {
                if (!layer._map) return;
                done(new Error('Tile load error'), tile);
              };
            } else {
              // No tile data - return transparent tile
              tile.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
              if (!layer._map) return;
              done(null, tile);
            }
          }).catch(err => {
            // Return transparent tile on error
            tile.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
            if (!layer._map) return;
            done(null, tile);
          });

          return tile;
        };

        this.cache[date] = { layer };
        return this.cache[date];
      }


      waitForLayer(layer) {
        return new Promise(resolve => {
          if (layer._tiles && Object.keys(layer._tiles).length > 0) return resolve();
          const onload = () => { layer.off('load', onload); resolve(); };
          layer.on('load', onload);
          setTimeout(() => { layer.off('load', onload); resolve(); }, 2000);
        });
      }

      async showFrame(index) {
        const currentFrame = CONFIG.frames[index];
        const loader = document.getElementById('loader');
        const spinnerTimeout = setTimeout(() => loader.classList.add('active'), 100);
        const requestId = ++this.requestCounter;

        // Get layer for the selected date only
        const data = this.getLayerData(currentFrame.date, currentFrame.url);
        if (!data || !data.layer) {
          clearTimeout(spinnerTimeout);
          loader.classList.remove('active');
          return;
        }

        const newLayer = data.layer;
        newLayer.setZIndex(10);
        const oldLayers = [...this.activeLayers];
        const opacityValue = parseFloat(document.getElementById('toolOpacitySlider')?.value || 100) / 100;

        // If we're already displaying this layer, just sync opacity and return
        if (this.activeLayers[0] === newLayer) {
          newLayer.setOpacity(opacityValue);
          clearTimeout(spinnerTimeout);
          loader.classList.remove('active');
          return;
        }

        // Add new layer at opacity 0 (hidden)
        if (!this.map.hasLayer(newLayer)) {
          newLayer.setOpacity(0);
          newLayer.addTo(this.map);
        }

        const tilesReady = () => {
          const tiles = newLayer._tiles;
          return tiles && Object.keys(tiles).length > 0 && Object.values(tiles).every(t => t.loaded);
        };

        const stopSpinner = () => {
          clearTimeout(spinnerTimeout);
          loader.classList.remove('active');
        };

        const removeIfInactive = () => {
          if (!this.activeLayers.includes(newLayer) && this.map.hasLayer(newLayer)) {
            this.map.removeLayer(newLayer);
          }
        };

        const finalizeSwap = () => {
          // Ignore stale requests
          if (requestId !== this.requestCounter) {
            removeIfInactive();
            stopSpinner();
            return;
          }

          requestAnimationFrame(() => {
            newLayer.setOpacity(opacityValue);
            oldLayers.forEach(l => { if (l !== newLayer && this.map.hasLayer(l)) this.map.removeLayer(l); });
            this.activeLayers = [newLayer];
            stopSpinner();
          });
        };

        const bailOut = (notify = true) => {
          if (requestId !== this.requestCounter) {
            removeIfInactive();
            stopSpinner();
            return;
          }
          removeIfInactive();
          stopSpinner();
          if (notify) Utils.toast('Chart failed to load; keeping previous map');
        };

        const cleanupListeners = (onLoadFn, onErrorFn) => {
          newLayer.off('load', onLoadFn);
          newLayer.off('tileerror', onErrorFn);
        };

        // If tiles already cached and ready, swap immediately
        if (tilesReady()) {
          finalizeSwap();
        } else {
          const onLoad = () => {
            cleanupListeners(onLoad, onError);
            finalizeSwap();
          };

          const onError = () => {
            cleanupListeners(onLoad, onError);
            bailOut();
          };

          newLayer.on('load', onLoad);
          newLayer.on('tileerror', onError);

          // Fallback: if layer still isn't ready after timeout, keep current map to avoid flicker
          setTimeout(() => {
            cleanupListeners(onLoad, onError);
            if (tilesReady()) {
              finalizeSwap();
            } else {
              bailOut(false);
            }
          }, 10000);
        }

        // Preload 3 frames before and 3 after, clean up others
        this.manageCache(index);
      }

      manageCache(currentIndex) {
        const BUFFER = 3; // Keep 3 before and 3 after
        const totalFrames = CONFIG.frames.length;

        // Calculate which indices to keep
        const keepIndices = new Set();
        for (let offset = -BUFFER; offset <= BUFFER; offset++) {
          let idx = currentIndex + offset;
          // Wrap around for circular navigation
          if (idx < 0) idx = totalFrames + idx;
          if (idx >= totalFrames) idx = idx - totalFrames;
          keepIndices.add(idx);
        }

        // Preload frames in the buffer
        keepIndices.forEach(idx => {
          if (idx !== currentIndex) {
            const frame = CONFIG.frames[idx];
            // Just create the layer data (doesn't add to map)
            this.getLayerData(frame.date, frame.url);
          }
        });

        // Clean up frames outside the buffer
        const frameDates = CONFIG.frames.map(f => f.date);
        Object.keys(this.cache).forEach(date => {
          const frameIndex = frameDates.indexOf(date);
          if (frameIndex !== -1 && !keepIndices.has(frameIndex)) {
            const cached = this.cache[date];
            // Remove layer from map if mounted
            if (cached.layer && this.map.hasLayer(cached.layer)) {
              this.map.removeLayer(cached.layer);
            }
            // Clean up PMTiles instance
            if (this.pmtilesInstances[date]) {
              delete this.pmtilesInstances[date];
            }
            // Remove from cache
            delete this.cache[date];
          }
        });
      }

      setOpacity(opacity) {
        this.activeLayers.forEach(layer => layer.setOpacity(opacity));
      }
    }

    /** TIMELINE CONTROLLER **/
    class TimelineApp {
      constructor(mapController) {
        this.mapCtrl = mapController;
        this.frames = CONFIG.frames;

        const dates = this.frames.map(f => new Date(f.date).getTime());
        const min = Math.min(...dates);
        const max = Math.max(...dates);
        this.frames.forEach((f, i) => { const d = dates[i]; f.pct = max === min ? 0 : ((d - min) / (max - min)) * 100; });

        this.currentIndex = 0;
        this.isPlaying = false;
        this.playInterval = null;
        this.playbackSpeed = 1;

        this.ui = {
          prevBtn: document.getElementById('prevBtn'),
          nextBtn: document.getElementById('nextBtn'),
          playBtn: document.getElementById('playBtn'),
          progress: document.getElementById('progress'),
          handle: document.getElementById('handle'),
          track: document.getElementById('trackWrapper'),
          timeSelect: document.getElementById('timeSelect'),
          lblRange: document.getElementById('lblRange'),
          ticks: document.getElementById('ticksContainer')
        };

        this.initUI();
        this.initControls();
        this.update(this.frames.length - 1); // Start at most recent

        window.addEventListener('keydown', (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

          if (e.key === 'ArrowRight') this.step(1);
          if (e.key === 'ArrowLeft') this.step(-1);
          if (e.key === ' ') {
            e.preventDefault();
            this.togglePlay();
          }
          if (e.key === 'f' || e.key === 'F') {
            e.preventDefault();
            Utils.toggleFullscreen();
          }
          if (e.key === 's' || e.key === 'S') {
            e.preventDefault();
            const sharePanel = document.getElementById('sharePanel');
            const wasVisible = sharePanel.classList.contains('visible');
            this.hideAllPanels();
            if (!wasVisible) {
              this.updateShareUrl();
              sharePanel.classList.add('visible');
            }
          }
          if (e.key === '?') {
            e.preventDefault();
            document.getElementById('shortcutsOverlay').classList.add('visible');
          }
          if (e.key === 'Escape') {
            document.getElementById('shortcutsOverlay').classList.remove('visible');
            this.hideAllPanels();
          }
        });
      }

      initControls() {
        // Help button
        document.getElementById('helpBtn')?.addEventListener('click', () => {
          document.getElementById('shortcutsOverlay').classList.add('visible');
          this.hideAllPanels(['shortcutsOverlay']);
        });

        document.getElementById('closeShortcuts')?.addEventListener('click', () => {
          document.getElementById('shortcutsOverlay').classList.remove('visible');
        });

        document.getElementById('shortcutsOverlay')?.addEventListener('click', (e) => {
          if (e.target.id === 'shortcutsOverlay') {
            document.getElementById('shortcutsOverlay').classList.remove('visible');
          }
        });

        // Fullscreen button
        document.getElementById('fullscreenBtn')?.addEventListener('click', () => {
          Utils.toggleFullscreen();
        });

        // Map Tools Panel
        const mapToolsBtn = document.getElementById('mapToolsBtn');
        const mapToolsPanel = document.getElementById('mapToolsPanel');
        const toolOpacitySlider = document.getElementById('toolOpacitySlider');
        const toolOpacityValue = document.getElementById('toolOpacityValue');

        mapToolsBtn?.addEventListener('click', () => {
          const wasVisible = mapToolsPanel.classList.contains('visible');
          this.hideAllPanels();
          if (!wasVisible) mapToolsPanel.classList.add('visible');
        });

        toolOpacitySlider?.addEventListener('input', (e) => {
          const value = e.target.value;
          toolOpacityValue.textContent = value;
          this.mapCtrl.setOpacity(value / 100);
          // Sync with old opacity slider if it exists
          const oldOpacitySlider = document.getElementById('opacitySlider');
          const oldOpacityValue = document.getElementById('opacityValue');
          if (oldOpacitySlider) oldOpacitySlider.value = value;
          if (oldOpacityValue) oldOpacityValue.textContent = value;
        });

        // Legacy Opacity control (keep for backward compatibility)
        const opacityBtn = document.getElementById('opacityBtn');
        const opacityControl = document.getElementById('opacityControl');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');

        opacityBtn?.addEventListener('click', () => {
          const wasVisible = opacityControl.classList.contains('visible');
          this.hideAllPanels();
          if (!wasVisible) opacityControl.classList.add('visible');
        });

        opacitySlider?.addEventListener('input', (e) => {
          const value = e.target.value;
          opacityValue.textContent = value;
          this.mapCtrl.setOpacity(value / 100);
          // Sync with new tool slider
          if (toolOpacitySlider) toolOpacitySlider.value = value;
          if (toolOpacityValue) toolOpacityValue.textContent = value;
        });

        // Share button
        const shareBtn = document.getElementById('shareBtn');
        const sharePanel = document.getElementById('sharePanel');
        const shareUrl = document.getElementById('shareUrl');
        const copyBtn = document.getElementById('copyBtn');

        shareBtn?.addEventListener('click', () => {
          const wasVisible = sharePanel.classList.contains('visible');
          this.hideAllPanels();
          if (!wasVisible) {
            this.updateShareUrl();
            sharePanel.classList.add('visible');
          }
        });

        copyBtn?.addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(shareUrl.value);
            copyBtn.textContent = '‚úì Copied';
            copyBtn.classList.add('copied');
            setTimeout(() => {
              copyBtn.textContent = 'Copy';
              copyBtn.classList.remove('copied');
            }, 2000);
          } catch (err) {
            // Fallback for browsers without clipboard API support
            try {
              shareUrl.select();
              shareUrl.setSelectionRange(0, 99999); // For mobile devices
              const success = document.execCommand('copy');
              if (success) {
                copyBtn.textContent = '‚úì Copied';
                copyBtn.classList.add('copied');
                setTimeout(() => {
                  copyBtn.textContent = 'Copy';
                  copyBtn.classList.remove('copied');
                }, 2000);
              } else {
                Utils.toast('Please manually copy the URL');
              }
            } catch (fallbackErr) {
              Utils.toast('Please manually copy the URL');
            }
          }
        });

        // Play button
        this.ui.playBtn?.addEventListener('click', () => {
          this.togglePlay();
        });

        // Speed Control
        const speedBtns = document.querySelectorAll('.speed-btn');
        speedBtns.forEach(btn => {
          btn.addEventListener('click', () => {
            const speed = parseFloat(btn.dataset.speed);
            this.playbackSpeed = speed;

            // Update active state and aria-pressed
            speedBtns.forEach(b => {
              b.classList.remove('active');
              b.setAttribute('aria-pressed', 'false');
            });
            btn.classList.add('active');
            btn.setAttribute('aria-pressed', 'true');

            // Update interval if playing
            if (this.isPlaying && this.playInterval) {
              clearInterval(this.playInterval);
              this.playInterval = setInterval(() => {
                this.step(1);
              }, 2000 / this.playbackSpeed);
            }
          });
        });

        // Chart Info Panel
        const chartInfoBtn = document.getElementById('chartInfoBtn');
        const chartInfoPanel = document.getElementById('chartInfoPanel');

        chartInfoBtn?.addEventListener('click', () => {
          const wasVisible = chartInfoPanel.classList.contains('visible');
          this.hideAllPanels();
          if (!wasVisible) chartInfoPanel.classList.add('visible');
        });
      }

      hideAllPanels(except = []) {
        const panels = ['opacityControl', 'sharePanel', 'mapToolsPanel', 'chartInfoPanel'];
        panels.forEach(id => {
          if (!except.includes(id)) {
            document.getElementById(id)?.classList.remove('visible');
          }
        });
      }

      updateShareUrl() {
        const frame = this.frames[this.currentIndex];
        const center = this.mapCtrl.map.getCenter();
        const zoom = this.mapCtrl.map.getZoom();
        const url = `${window.location.origin}${window.location.pathname}?date=${frame.date}&lat=${center.lat.toFixed(4)}&lng=${center.lng.toFixed(4)}&zoom=${zoom}`;
        document.getElementById('shareUrl').value = url;
      }

      togglePlay() {
        this.isPlaying = !this.isPlaying;
        const playBtn = this.ui.playBtn;

        if (this.isPlaying) {
          playBtn.textContent = '‚è∏';
          playBtn.title = 'Pause (Space)';
          playBtn.setAttribute('aria-label', 'Pause animation');
          this.playInterval = setInterval(() => {
            this.step(1);
          }, 2000 / this.playbackSpeed);
        } else {
          playBtn.textContent = '‚ñ∂';
          playBtn.title = 'Play (Space)';
          playBtn.setAttribute('aria-label', 'Play animation');
          if (this.playInterval) {
            clearInterval(this.playInterval);
            this.playInterval = null;
          }
        }
      }

      initUI() {
        this.ui.lblRange.textContent = `${this.frames[0].id} ‚Äî ${this.frames[this.frames.length - 1].id}`;

        // Setup date picker with min/max and default to most recent
        const firstDate = this.frames[0].date;
        const lastDate = this.frames[this.frames.length - 1].date;
        this.ui.timeSelect.min = firstDate;
        this.ui.timeSelect.max = lastDate;
        this.ui.timeSelect.value = lastDate; // Default to most recent

        // Start at most recent frame
        this.currentIndex = this.frames.length - 1;

        this.ui.timeSelect.addEventListener('change', () => {
          const selectedDate = this.ui.timeSelect.value;
          if (!selectedDate) return;

          // Find the most recent frame on or before the selected date (never round forward)
          const selectedTime = new Date(selectedDate).getTime();
          let bestIdx = 0;
          let bestTime = -Infinity;

          this.frames.forEach((f, i) => {
            const frameTime = new Date(f.date).getTime();
            // Only consider dates on or before selected date
            if (frameTime <= selectedTime && frameTime > bestTime) {
              bestTime = frameTime;
              bestIdx = i;
            }
          });

          // If no date found on or before (user selected before earliest), use the first frame
          if (bestTime === -Infinity) {
            bestIdx = 0;
          }

          this.update(bestIdx);
        });

        // ticks with year labels
        const years = new Set();
        this.frames.forEach((f, i) => {
          const tick = document.createElement('div');
          tick.className = 'tick';
          tick.style.left = `${f.pct}%`;

          // Extract year from date
          const year = f.date.split('-')[0];

          // Mark as major tick if it's a new year or every 5th year
          if (!years.has(year)) {
            years.add(year);
            const yearNum = parseInt(year);
            if (yearNum % 5 === 0 || i === 0 || i === this.frames.length - 1) {
              tick.classList.add('major');
              const label = document.createElement('div');
              label.className = 'tick-label';
              label.textContent = year;
              tick.appendChild(label);
            }
          }

          this.ui.ticks.appendChild(tick);
        });

        // Jog Controls
        this.ui.prevBtn.onclick = () => this.step(-1);
        this.ui.nextBtn.onclick = () => this.step(1);

        // drag on the track/handle
        const handleInput = (clientX) => {
          const rect = this.ui.track.getBoundingClientRect();
          const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
          const pct = (x / rect.width) * 100;

          let closestIdx = 0, minDiff = Infinity;
          this.frames.forEach((f, i) => {
            const diff = Math.abs(f.pct - pct);
            if (diff < minDiff) { minDiff = diff; closestIdx = i; }
          });

          if (closestIdx !== this.currentIndex) this.update(closestIdx, true);
        };

        let isDragging = false;
        const startDrag = (e) => {
          isDragging = true;
          handleInput((e.touches?.[0]?.clientX) ?? e.clientX);
        };
        const moveDrag = (e) => { if (isDragging) handleInput((e.touches?.[0]?.clientX) ?? e.clientX); };
        const endDrag = () => { isDragging = false; };

        this.ui.track.addEventListener('mousedown', startDrag);
        this.ui.track.addEventListener('touchstart', startDrag, { passive: false });
        window.addEventListener('mousemove', moveDrag);
        window.addEventListener('touchmove', moveDrag, { passive: false });
        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);
      }

      update(index, lazy = false) {
        this.currentIndex = index;
        const f = this.frames[index];

        // Update date picker to show the current frame's date
        if (this.ui.timeSelect && this.ui.timeSelect.value !== f.date) {
          this.ui.timeSelect.value = f.date;
        }

        this.ui.handle.style.left = `${f.pct}%`;
        this.ui.progress.style.width = `${f.pct}%`;

        Array.from(this.ui.ticks.children).forEach((tick, i) => {
          if (i === index) tick.classList.add('active'); else tick.classList.remove('active');
        });

        if (lazy) {
          this.mapCtrl.showFrameDebounced(index);
        } else {
          this.mapCtrl.showFrame(index);
        }
      }

      step(dir) {
        let next = this.currentIndex + dir;
        if (next >= this.frames.length) next = 0;
        if (next < 0) next = this.frames.length - 1;
        this.update(next);
      }
    }

    // Initialize Application
    async function initApp() {
      // Loading progress elements
      const loadingSplash = document.getElementById('loadingSplash');
      const loadingProgressBar = document.getElementById('loadingProgressBar');
      const loadingStatus = document.getElementById('loadingStatus');

      const updateLoading = (percent, status) => {
        loadingProgressBar.style.width = `${percent}%`;
        loadingStatus.textContent = status;
      };

      updateLoading(10, 'Loading timeline data...');

      // Show warning banner temporarily
      const warningOverlay = document.getElementById('warningOverlay');
      setTimeout(() => warningOverlay.classList.add('visible'), 1500);
      setTimeout(() => warningOverlay.classList.remove('visible'), 8000);

      await loadData(); // Fetch and parse CSV first
      updateLoading(40, 'Initializing map...');

      if (CONFIG.frames.length === 0) {
        Utils.toast("No valid frames found in CSV");
        loadingSplash.classList.add('hidden');
        return;
      }

      const mapCtrl = new MapController('map');
      updateLoading(70, 'Loading controls...');

      const timelineApp = new TimelineApp(mapCtrl);
      updateLoading(90, 'Almost ready...');

      // Handle URL parameters for shared links
      const urlParams = new URLSearchParams(window.location.search);
      const dateParam = urlParams.get('date');
      const latParam = urlParams.get('lat');
      const lngParam = urlParams.get('lng');
      const zoomParam = urlParams.get('zoom');

      // Set map position from URL if available
      if (latParam && lngParam && zoomParam) {
        const lat = parseFloat(latParam);
        const lng = parseFloat(lngParam);
        const zoom = parseInt(zoomParam);
        if (!isNaN(lat) && !isNaN(lng) && !isNaN(zoom)) {
          mapCtrl.map.setView([lat, lng], zoom);
        }
      }

      // Set timeframe from URL if available
      if (dateParam) {
        const frameIndex = CONFIG.frames.findIndex(f => f.date === dateParam);
        if (frameIndex >= 0) {
          timelineApp.update(frameIndex);
        }
      }

      // Location Crosshair Button - Request User's Geolocation
      const locateBtn = document.getElementById('locateBtn');
      locateBtn?.addEventListener('click', () => {
        if ('geolocation' in navigator) {
          Utils.toast('Getting your location...');
          navigator.geolocation.getCurrentPosition(
            (position) => {
              const lat = position.coords.latitude;
              const lng = position.coords.longitude;
              mapCtrl.map.flyTo([lat, lng], 10, { duration: 1.5 });
              Utils.toast('Centered on your location');
            },
            (error) => {
              console.error('Geolocation error:', error);
              let message = 'Unable to get your location';
              if (error.code === error.PERMISSION_DENIED) {
                message = 'Location permission denied';
              } else if (error.code === error.POSITION_UNAVAILABLE) {
                message = 'Location unavailable';
              } else if (error.code === error.TIMEOUT) {
                message = 'Location request timed out';
              }
              Utils.toast(message);
            },
            {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 0
            }
          );
        } else {
          Utils.toast('Geolocation not supported by your browser');
        }
      });

      // --- Side-by-Side Comparison Logic ---
      const mapCtrl2 = new MapController('map2');
      const compareBtn = document.getElementById('compareBtn'); // Old location (if exists)
      const toolCompareBtn = document.getElementById('toolCompareBtn'); // New location in map tools
      const map2Controls = document.querySelector('.map2-controls');
      const map2TimeSelect = document.getElementById('map2TimeSelect');
      let isCompareMode = false;
      let isSyncing = false;

      // Setup Map 2 date picker
      const firstDate = CONFIG.frames[0].date;
      const lastDate = CONFIG.frames[CONFIG.frames.length - 1].date;
      map2TimeSelect.min = firstDate;
      map2TimeSelect.max = lastDate;
      map2TimeSelect.value = lastDate;

      map2TimeSelect.addEventListener('change', () => {
        const selectedDate = map2TimeSelect.value;
        if (!selectedDate) return;

        // Find the most recent frame on or before the selected date (never round forward)
        const selectedTime = new Date(selectedDate).getTime();
        let bestIdx = 0;
        let bestTime = -Infinity;

        CONFIG.frames.forEach((f, i) => {
          const frameTime = new Date(f.date).getTime();
          if (frameTime <= selectedTime && frameTime > bestTime) {
            bestTime = frameTime;
            bestIdx = i;
          }
        });

        // If no date found on or before, use the first frame
        if (bestTime === -Infinity) {
          bestIdx = 0;
        }

        // Update picker to show the actual available date
        map2TimeSelect.value = CONFIG.frames[bestIdx].date;
        mapCtrl2.showFrame(bestIdx);
      });

      // Sync Maps Function with debouncing to prevent infinite loops
      let syncTimeout = null;
      function syncMaps(source, target) {
        if (!isCompareMode || isSyncing) return;
        isSyncing = true;

        // Clear any pending sync timeout
        if (syncTimeout) {
          clearTimeout(syncTimeout);
        }

        target.setView(source.getCenter(), source.getZoom(), { animate: false });

        // Reset flag after a short delay to ensure all events are processed
        syncTimeout = setTimeout(() => {
          isSyncing = false;
          syncTimeout = null;
        }, 50);
      }

      mapCtrl.map.on('moveend', () => syncMaps(mapCtrl.map, mapCtrl2.map));
      mapCtrl2.map.on('moveend', () => syncMaps(mapCtrl2.map, mapCtrl.map));

      // Toggle Compare Mode Function
      function toggleCompareMode() {
        isCompareMode = !isCompareMode;
        document.body.classList.toggle('split-view', isCompareMode);

        // Update both button states if they exist
        if (compareBtn) compareBtn.classList.toggle('active', isCompareMode);
        if (toolCompareBtn) toolCompareBtn.classList.toggle('active', isCompareMode);

        // Resize maps
        mapCtrl.map.invalidateSize();
        mapCtrl2.map.invalidateSize();

        if (isCompareMode) {
          // Init Map 2 state if needed
          const currentIdx = timelineApp.currentIndex;
          // Default map 2 to either same or previous frame
          let compareIdx = currentIdx > 0 ? currentIdx - 1 : currentIdx;
          map2TimeSelect.value = CONFIG.frames[compareIdx].date;
          mapCtrl2.showFrame(compareIdx);

          // Sync view to Map 1 immediately
          mapCtrl2.map.setView(mapCtrl.map.getCenter(), mapCtrl.map.getZoom(), { animate: false });

          Utils.toast("Compare Mode: On");
        } else {
          Utils.toast("Compare Mode: Off");
          // Optional: clear map2 layers to save resources? 
          // For now, keep them.
        }
      }

      // Toggle Compare Mode - bind to both buttons
      compareBtn?.addEventListener('click', toggleCompareMode);
      toolCompareBtn?.addEventListener('click', toggleCompareMode);

      // Update chart info panel with initial data
      const chartInfoDate = document.getElementById('chartInfoDate');
      const chartInfoTotal = document.getElementById('chartInfoTotal');
      const chartInfoZoom = document.getElementById('chartInfoZoom');
      chartInfoTotal.textContent = CONFIG.frames.length.toString();

      // Update zoom level display
      const updateZoomDisplay = () => {
        if (chartInfoZoom) {
          chartInfoZoom.textContent = mapCtrl.map.getZoom().toFixed(2);
        }
      };
      mapCtrl.map.on('zoomend', updateZoomDisplay);
      updateZoomDisplay(); // Initial value

      // History Range Feature
      const historyDaysInput = document.getElementById('historyDaysInput');
      const historyHint = document.getElementById('historyHint');
      let historyRangeDays = 0;

      // Store reference to showFrameRange on mapCtrl for multi-layer display
      mapCtrl.showFrameRange = function(endIndex, days) {
        const loader = document.getElementById('loader');
        const spinnerTimeout = setTimeout(() => loader.classList.add('active'), 100);

        const endFrame = CONFIG.frames[endIndex];
        const endDate = new Date(endFrame.date);
        const startDate = new Date(endDate);
        startDate.setDate(startDate.getDate() - days);

        // Find all frames within the date range
        const framesInRange = [];
        CONFIG.frames.forEach((frame, idx) => {
          const frameDate = new Date(frame.date);
          if (frameDate >= startDate && frameDate <= endDate) {
            framesInRange.push({ frame, idx });
          }
        });

        const opacityValue = parseFloat(document.getElementById('toolOpacitySlider')?.value || 100) / 100;
        const oldLayers = [...this.activeLayers];

        // Add all layers in range (oldest first so newest is on top)
        const newLayers = [];
        framesInRange.forEach(({ frame }, i) => {
          const data = this.getLayerData(frame.date, frame.url);
          if (data && data.layer) {
            const layer = data.layer;
            // Calculate opacity - newer layers are more opaque
            const layerOpacity = opacityValue * (0.3 + 0.7 * (i / Math.max(framesInRange.length - 1, 1)));
            layer.setZIndex(10 + i);
            if (!this.map.hasLayer(layer)) {
              layer.addTo(this.map);
            }
            layer.setOpacity(layerOpacity);
            newLayers.push(layer);
          }
        });

        // Remove old layers not in new set
        oldLayers.forEach(l => {
          if (!newLayers.includes(l) && this.map.hasLayer(l)) {
            this.map.removeLayer(l);
          }
        });

        this.activeLayers = newLayers;

        clearTimeout(spinnerTimeout);
        loader.classList.remove('active');

        return framesInRange.length;
      };

      historyDaysInput?.addEventListener('input', (e) => {
        historyRangeDays = parseInt(e.target.value) || 0;

        if (historyRangeDays > 0) {
          const count = mapCtrl.showFrameRange(timelineApp.currentIndex, historyRangeDays);
          historyHint.textContent = `Showing ${count} map${count !== 1 ? 's' : ''}`;
        } else {
          historyHint.textContent = 'Set to 0 for single map';
          mapCtrl.showFrame(timelineApp.currentIndex);
        }
      });

      // Update chart info when frame changes
      const originalUpdate = timelineApp.update.bind(timelineApp);
      timelineApp.update = function(index, lazy) {
        originalUpdate(index, lazy);
        const frame = CONFIG.frames[index];
        if (chartInfoDate && frame) {
          chartInfoDate.textContent = Utils.formatDateId(frame.date);
        }

        // If history range is active, show range instead of single frame
        if (historyRangeDays > 0) {
          const count = mapCtrl.showFrameRange(index, historyRangeDays);
          historyHint.textContent = `Showing ${count} map${count !== 1 ? 's' : ''}`;
        }
      };

      // Hide loading splash
      updateLoading(100, 'Ready!');
      setTimeout(() => {
        loadingSplash.classList.add('hidden');
      }, 300);
    }

    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>

</html>
