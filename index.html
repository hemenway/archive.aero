<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>archive.aero - Historical Aeronautical Chart Viewer</title>
  <meta name="description"
    content="Explore historical aeronautical charts and sectional maps. View how aviation charts have evolved over time with AeroMap's interactive timeline viewer." />
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚úàÔ∏è</text></svg>" />

  <!-- Preload critical resources -->
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://data.archive.aero" crossorigin>
  <link rel="preconnect" href="https://basemaps.cartocdn.com" crossorigin>
  <link rel="dns-prefetch" href="https://ipapi.co">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root {
      --primary: #1e90ff;
      --primary-hover: #4da6ff;
      --secondary: #00d4aa;
      --bg-glass: rgba(20, 25, 30, 0.90);
      --bg-dark: #0a0e12;
      --text-light: #fff;
      --text-muted: rgba(255, 255, 255, 0.6);
      --timeline-h: 6px;
      --card-radius: 16px;
      --transition-smooth: cubic-bezier(0.4, 0.0, 0.2, 1);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg-dark);
      font-family: system-ui, -apple-system, sans-serif;
      overflow: hidden;
      color: var(--text-light);
    }

    * {
      box-sizing: border-box;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes loadingPulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }

    body {
      animation: fadeIn 0.3s ease-in;
    }

    /* Loading Splash Screen */
    .loading-splash {
      position: fixed;
      inset: 0;
      background: var(--bg-dark);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 24px;
      transition: opacity 0.5s var(--transition-smooth), visibility 0.5s;
    }

    .loading-splash.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    .loading-logo {
      font-size: 48px;
      animation: loadingPulse 2s ease-in-out infinite;
    }

    .loading-title {
      font-size: 28px;
      font-weight: 800;
      letter-spacing: -0.5px;
      color: var(--text-light);
    }

    .loading-progress {
      width: 200px;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s var(--transition-smooth);
    }

    .loading-status {
      font-size: 13px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #map {
      height: 100%;
      width: 100%;
      z-index: 1;
      background: var(--bg-dark);
    }

    /* Header Bar */
    .header-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: linear-gradient(180deg, var(--bg-glass) 0%, transparent 100%);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      z-index: 900;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      pointer-events: none;
    }

    .header-content {
      display: flex;
      align-items: center;
      gap: 16px;
      pointer-events: auto;
    }

    .site-logo {
      font-size: 24px;
      font-weight: 800;
      letter-spacing: -0.5px;
      color: var(--text-light);
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: color 0.2s var(--transition-smooth);
    }

    .site-logo:hover {
      color: var(--primary-hover);
    }

    .site-tagline {
      font-size: 13px;
      color: var(--text-muted);
      font-weight: 500;
      display: none;
    }

    .donate-btn {
      background: linear-gradient(135deg, #ff813f 0%, #ffdd00 100%);
      color: #000;
      padding: 8px 14px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 700;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s var(--transition-smooth);
      box-shadow: 0 2px 8px rgba(255, 129, 63, 0.3);
    }

    .donate-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(255, 129, 63, 0.5);
    }

    .sources-link {
      position: fixed;
      bottom: 12px;
      left: 12px;
      background: var(--bg-glass);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      color: var(--text-muted);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 11px;
      text-decoration: none;
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 1000;
      transition: all 0.2s var(--transition-smooth);
    }

    .sources-link:hover {
      color: var(--text-light);
      border-color: var(--primary);
    }

    .header-actions {
      display: flex;
      gap: 8px;
      pointer-events: auto;
      align-items: center;
    }

    .btn-group {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .btn-separator {
      width: 1px;
      height: 24px;
      background: rgba(255, 255, 255, 0.2);
      margin: 0 4px;
    }

    .icon-btn {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 18px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: all 0.2s var(--transition-smooth);
      text-decoration: none;
    }

    .icon-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: var(--primary);
      transform: translateY(-2px);
    }

    .icon-btn:active {
      transform: translateY(0);
    }

    /* Map Performance Tweaks */
    .leaflet-fade-anim .leaflet-tile,
    .leaflet-zoom-anim .leaflet-zoom-animated {
      will-change: transform;
    }

    /* Leaflet Controls Styling - Dark Glass Theme */
    .leaflet-control-zoom {
      border: none !important;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4) !important;
    }

    .leaflet-control-zoom a {
      background: var(--bg-glass) !important;
      backdrop-filter: blur(12px) !important;
      -webkit-backdrop-filter: blur(12px) !important;
      color: var(--text-light) !important;
      border: 1px solid rgba(255, 255, 255, 0.1) !important;
      width: 36px !important;
      height: 36px !important;
      line-height: 36px !important;
      font-size: 18px !important;
      font-weight: 400 !important;
      transition: all 0.2s var(--transition-smooth) !important;
    }

    .leaflet-control-zoom a:hover {
      background: rgba(255, 255, 255, 0.15) !important;
      border-color: var(--primary) !important;
      color: var(--primary) !important;
    }

    .leaflet-control-zoom-in {
      border-radius: 10px 10px 0 0 !important;
    }

    .leaflet-control-zoom-out {
      border-radius: 0 0 10px 10px !important;
      border-top: none !important;
    }

    .leaflet-control-attribution {
      background: var(--bg-glass) !important;
      backdrop-filter: blur(8px) !important;
      -webkit-backdrop-filter: blur(8px) !important;
      color: var(--text-muted) !important;
      font-size: 10px !important;
      padding: 4px 8px !important;
      border-radius: 6px 0 0 0 !important;
    }

    .leaflet-control-attribution a {
      color: var(--primary) !important;
    }

    /* Push map controls below the header bar */
    .leaflet-top {
      margin-top: 80px;
    }

    /* UI Container */
    .ui-layer {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: min(1000px, 94vw);
      z-index: 1000;
      pointer-events: none;
    }

    /* Main Control Card */
    .controls-card {
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 16px 24px;
      border-radius: var(--card-radius);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      gap: 20px;
      pointer-events: auto;
    }

    /* Jog Controls (Forward/Back) */
    .jog-controls {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
    }

    .btn-nav {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 18px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: all 0.2s var(--transition-smooth);
    }

    .btn-nav:hover {
      background: var(--primary);
      border-color: var(--primary);
      box-shadow: 0 4px 12px rgba(30, 144, 255, 0.4);
      transform: scale(1.05);
    }

    .btn-nav:active {
      transform: scale(0.95);
    }

    .btn-nav:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      transform: none;
    }

    /* Play button */
    .btn-play {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: all 0.2s var(--transition-smooth);
      box-shadow: 0 4px 12px rgba(30, 144, 255, 0.3);
    }

    .btn-play:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 20px rgba(30, 144, 255, 0.5);
    }

    .btn-play:active {
      transform: scale(0.98);
    }

    /* Timeline Track */
    .timeline-track-wrapper {
      flex: 1;
      position: relative;
      height: 50px;
      display: flex;
      align-items: center;
      cursor: pointer;
      touch-action: none;
    }

    .timeline-track {
      width: 100%;
      height: var(--timeline-h);
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      position: relative;
    }

    .timeline-progress {
      position: absolute;
      height: 100%;
      background: var(--primary);
      border-radius: 4px;
      width: 0%;
      pointer-events: none;
    }

    .tick {
      position: absolute;
      width: 2px;
      height: 12px;
      background: rgba(255, 255, 255, 0.4);
      top: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      transition: height 0.2s, background 0.2s;
    }

    .tick.active {
      background: var(--primary);
      height: 18px;
      width: 3px;
      opacity: 1;
      box-shadow: 0 0 12px var(--primary);
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        box-shadow: 0 0 12px var(--primary);
      }

      50% {
        box-shadow: 0 0 20px var(--primary), 0 0 30px rgba(30, 144, 255, 0.5);
      }
    }

    .tick.major {
      height: 16px;
      background: rgba(255, 255, 255, 0.6);
    }

    .tick-label {
      position: absolute;
      bottom: -24px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: var(--text-muted);
      white-space: nowrap;
      pointer-events: none;
      font-weight: 600;
    }

    /* Slider Handle */
    .handle {
      position: absolute;
      width: 22px;
      height: 22px;
      background: linear-gradient(135deg, #fff 0%, #e0e0e0 100%);
      border-radius: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 0 4px rgba(30, 144, 255, 0.5), 0 4px 12px rgba(0, 0, 0, 0.3);
      cursor: grab;
      transition: all 0.2s var(--transition-smooth);
      z-index: 2;
    }

    .handle::after {
      content: '';
      position: absolute;
      top: -15px;
      left: -15px;
      right: -15px;
      bottom: -15px;
    }

    .handle:hover {
      transform: translate(-50%, -50%) scale(1.1);
      box-shadow: 0 0 0 5px rgba(30, 144, 255, 0.6), 0 4px 16px rgba(0, 0, 0, 0.4);
    }

    .handle:active {
      cursor: grabbing;
      transform: translate(-50%, -50%) scale(1.2);
    }

    /* Info Panel */
    .info-panel {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 100px;
      color: var(--text-light);
      text-align: right;
    }

    .label-sub {
      font-size: 11px;
      opacity: 0.6;
      margin-top: 4px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Loader */
    .loader {
      width: 18px;
      height: 18px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      opacity: 0;
      transition: opacity 0.2s;
      margin-right: 10px;
    }

    .loader.active {
      opacity: 1;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Toast */
    .toast {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #e74c3c;
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 13px;
      z-index: 2000;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .toast.visible {
      opacity: 1;
    }

    /* Date picker styling */
    .time-select {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-light);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: -0.3px;
      line-height: 1;
      outline: none;
      cursor: pointer;
      transition: all 0.2s var(--transition-smooth);
      color-scheme: dark;
    }

    .time-select:hover {
      background-color: rgba(255, 255, 255, 0.12);
      border-color: var(--primary);
    }

    .time-select:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(30, 144, 255, 0.2);
    }

    /* Style the date picker icon */
    .time-select::-webkit-calendar-picker-indicator {
      filter: invert(1);
      cursor: pointer;
    }

    /* Keyboard Shortcuts Overlay */
    .shortcuts-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s var(--transition-smooth);
    }

    .shortcuts-overlay.visible {
      display: flex;
      opacity: 1;
    }

    .shortcuts-content {
      background: var(--bg-glass);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 20px;
      padding: 32px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .shortcuts-content h2 {
      margin: 0 0 24px 0;
      font-size: 24px;
      font-weight: 800;
      color: var(--text-light);
    }

    .shortcut-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .shortcut-item:last-child {
      border-bottom: none;
    }

    .shortcut-desc {
      font-size: 14px;
      color: var(--text-light);
    }

    .shortcut-key {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 600;
      font-family: 'Courier New', monospace;
      color: var(--primary);
    }

    .close-shortcuts {
      width: 100%;
      margin-top: 24px;
      padding: 12px;
      background: var(--primary);
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s var(--transition-smooth);
    }

    .close-shortcuts:hover {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(30, 144, 255, 0.4);
    }

    /* Hide keyboard shortcuts on mobile */
    @media (max-width: 640px) {
      #helpBtn {
        display: none;
      }
    }

    /* Share Panel */
    .share-panel {
      position: absolute;
      top: 160px;
      right: 24px;
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 16px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 900;
      min-width: 280px;
      display: none;
    }

    .share-panel.visible {
      display: block;
    }

    .share-panel h4 {
      margin: 0 0 12px 0;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .share-url-box {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    .share-url {
      flex: 1;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 10px;
      color: var(--text-light);
      font-size: 12px;
      font-family: 'Courier New', monospace;
      outline: none;
      user-select: all;
    }

    .share-url:focus {
      border-color: var(--primary);
      background: rgba(255, 255, 255, 0.08);
    }

    .copy-btn {
      padding: 10px 16px;
      background: var(--primary);
      border: none;
      border-radius: 8px;
      color: white;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s var(--transition-smooth);
      white-space: nowrap;
    }

    .copy-btn:hover {
      background: var(--primary-hover);
      transform: translateY(-1px);
    }

    .copy-btn:active {
      transform: translateY(0);
    }

    .copy-btn.copied {
      background: var(--secondary);
    }

    .share-info {
      font-size: 11px;
      color: var(--text-muted);
      text-align: center;
      margin-top: 8px;
    }



    /* Opacity Control */
    .opacity-control {
      position: absolute;
      top: 160px;
      right: 24px;
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 16px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 900;
      min-width: 200px;
      display: none;
    }

    .opacity-control.visible {
      display: block;
    }

    .opacity-control h4 {
      margin: 0 0 12px 0;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .opacity-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.2);
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .opacity-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .opacity-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .opacity-value {
      text-align: center;
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* --- MOBILE OPTIMIZATIONS --- */
    @media (max-width: 640px) {
      .header-bar {
        height: 60px;
        padding: 0 16px;
      }

      .site-logo {
        font-size: 20px;
      }

      .site-tagline {
        display: none;
      }

      .header-actions .icon-btn {
        width: 36px;
        height: 36px;
        font-size: 16px;
      }

      /* Hide fullscreen button on mobile */
      #fullscreenBtn {
        display: none;
      }

      .opacity-control,
      .share-panel,
      .map-tools-panel {
        position: fixed;
        top: auto;
        bottom: 160px;
        right: 12px;
        left: 12px;
        min-width: 0;
        max-height: 50vh;
        overflow-y: auto;
        z-index: 1100;
      }

      /* Hide separators on mobile to save space */
      .btn-separator {
        display: none;
      }

      .btn-group {
        gap: 4px;
      }

      .header-actions {
        gap: 4px;
      }

      .ui-layer {
        bottom: 16px;
        width: 94vw;
      }

      .leaflet-top {
        margin-top: 120px;
      }

      .controls-card {
        flex-wrap: wrap;
        padding: 12px 14px;
        gap: 10px;
        justify-content: center;
      }

      .jog-controls {
        order: 1;
      }

      .info-panel {
        order: 2;
        align-items: center;
        flex-direction: row;
        gap: 10px;
      }

      .label-sub {
        margin-top: 0;
        display: none;
      }

      .timeline-track-wrapper {
        order: 3;
        flex-basis: 100%;
        width: 100%;
        margin-top: 8px;
        height: 40px;
      }

      .loader {
        position: absolute;
        top: 16px;
        left: 110px;
      }

      .time-select {
        font-size: 15px;
        padding: 8px 34px 8px 10px;
      }

      .shortcuts-content {
        padding: 24px;
      }

      .shortcuts-content h2 {
        font-size: 20px;
      }

      .tick-label {
        display: none;
      }
    }

    /* Side-by-Side View */
    #map2 {
      position: absolute;
      top: 0;
      left: 50%;
      width: 50%;
      height: 100%;
      background: var(--bg-dark);
      z-index: 1;
      display: none;
      border-left: 2px solid rgba(0, 0, 0, 0.5);
    }

    body.split-view #map {
      width: 50%;
    }

    body.split-view #map2 {
      display: block;
    }

    /* Map 2 Controls (Floating) */
    .map2-controls {
      position: absolute;
      top: 80px;
      /* Below header */
      right: 20px;
      z-index: 1000;
      display: none;
    }

    body.split-view .map2-controls {
      display: block;
    }

    .btn-compare {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: white;
      font-size: 18px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: all 0.2s var(--transition-smooth);
    }

    .btn-compare:hover {
      background: var(--primary);
    }

    .btn-compare.active {
      background: var(--secondary);
      box-shadow: 0 0 15px rgba(0, 212, 170, 0.4);
    }

    @media (min-width: 768px) {
      .site-tagline {
        display: block;
      }
    }

    /* Warning Banner */
    .warning-overlay {
      position: absolute;
      top: 70px;
      /* Below header */
      left: 50%;
      transform: translateX(-50%);
      width: auto;
      height: auto;
      z-index: 2000;
      pointer-events: none;
      display: flex;
      justify-content: center;
      transition: opacity 0.5s ease, transform 0.5s ease;
      opacity: 0;
    }

    .warning-overlay.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(10px);
    }

    .warning-modal {
      background: rgba(255, 69, 58, 0.9);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 12px 24px;
      border-radius: 50px;
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      max-width: 90vw;
      width: auto;
      text-align: left;
    }

    .warning-icon {
      font-size: 18px;
      margin: 0;
      display: inline-block;
    }

    .warning-title {
      display: none;
      /* Hide title for banner */
    }

    .warning-text {
      font-size: 13px;
      font-weight: 600;
      color: white;
      margin: 0;
      line-height: 1.2;
    }

    .warning-btn {
      display: none;
      /* Auto-dismiss or small x? User said temporary banner. Let's hide button and auto-hide. */
    }

    /* Location Search */
    .search-container {
      position: relative;
      margin-right: 8px;
      width: 240px;
    }

    .search-input {
      width: 100%;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 10px 40px 10px 16px;
      color: white;
      font-size: 14px;
      transition: all 0.2s;
      backdrop-filter: blur(8px);
    }

    .search-input:focus {
      background: rgba(255, 255, 255, 0.15);
      border-color: var(--primary);
      outline: none;
      box-shadow: 0 0 0 4px rgba(30, 144, 255, 0.2);
    }

    .search-icon {
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      opacity: 0.6;
    }

    /* Adjust header layout for search */
    .header-content {
      flex: 1;
    }

    /* Map Tools Panel */
    .map-tools-panel {
      position: absolute;
      top: 160px;
      right: 24px;
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 16px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 900;
      min-width: 220px;
      display: none;
    }

    .map-tools-panel.visible {
      display: block;
    }

    .map-tools-panel h4 {
      margin: 0 0 16px 0;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .tool-section {
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .tool-section:last-child {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .tool-label {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 8px;
      display: block;
    }

    .tool-button {
      width: 100%;
      padding: 10px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      color: white;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s var(--transition-smooth);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .tool-button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: var(--primary);
    }

    .tool-button.active {
      background: var(--secondary);
      border-color: var(--secondary);
      box-shadow: 0 0 15px rgba(0, 212, 170, 0.4);
    }

    .tool-slider-container {
      margin-top: 8px;
    }

    .tool-slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.2);
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .tool-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .tool-slider::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      border: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .tool-value {
      text-align: center;
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* Speed Control */
    .speed-control {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: 8px;
    }

    .speed-btn {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--text-muted);
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: all 0.2s var(--transition-smooth);
    }

    .speed-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      color: var(--text-light);
    }

    .speed-btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    /* Chart Info Panel */
    .chart-info-panel {
      position: absolute;
      top: 160px;
      right: 24px;
      background: var(--bg-glass);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 16px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 900;
      min-width: 260px;
      display: none;
      animation: slideUp 0.2s var(--transition-smooth);
    }

    .chart-info-panel.visible {
      display: block;
    }

    .chart-info-panel h4 {
      margin: 0 0 16px 0;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-light);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .chart-info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .chart-info-row:last-child {
      border-bottom: none;
    }

    .chart-info-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    .chart-info-value {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-light);
    }

    .chart-badge {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .chart-badge.historical {
      background: rgba(255, 165, 0, 0.2);
      color: #ffa500;
    }

    .chart-badge.sectional {
      background: rgba(30, 144, 255, 0.2);
      color: var(--primary);
    }

    /* Empty State Message */
    .empty-state {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 800;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s var(--transition-smooth);
    }

    .empty-state.visible {
      opacity: 1;
    }

    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 16px;
    }

    .empty-state-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--text-light);
      margin-bottom: 8px;
    }

    .empty-state-text {
      font-size: 14px;
      color: var(--text-muted);
      max-width: 300px;
    }

    /* Warning Popup (Fixed Anchor) */

    @media (max-width: 640px) {
      .search-container {
        position: absolute;
        top: 65px;
        left: 12px;
        right: 12px;
        width: auto;
        margin-right: 0;
      }

      .search-input {
        width: 100%;
        font-size: 16px;
      }

      .speed-control {
        display: none;
      }

      .chart-info-panel {
        position: fixed;
        top: auto;
        bottom: 160px;
        right: 12px;
        left: 12px;
        min-width: 0;
      }

      .loading-logo {
        font-size: 36px;
      }

      .loading-title {
        font-size: 22px;
      }
    }

    /* Focus states for accessibility */
    .icon-btn:focus-visible,
    .btn-nav:focus-visible,
    .btn-play:focus-visible,
    .tool-button:focus-visible,
    .time-select:focus-visible {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }

    /* Reduced motion preference */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* High contrast mode */
    @media (prefers-contrast: high) {
      :root {
        --bg-glass: rgba(0, 0, 0, 0.95);
        --text-muted: rgba(255, 255, 255, 0.8);
      }
    }
  </style>

  <!-- Privacy-friendly analytics by Plausible -->
  <script async src="https://plausible.io/js/pa-m9DzDEgB7Ebb2zKdbBaMF.js"></script>
  <script>
    window.plausible = window.plausible || function () { (plausible.q = plausible.q || []).push(arguments) }, plausible.init = plausible.init || function (i) { plausible.o = i || {} };
    plausible.init()
  </script>

</head>

<body>

  <!-- Loading Splash Screen -->
  <div class="loading-splash" id="loadingSplash" role="status" aria-live="polite">
    <div class="loading-logo" aria-hidden="true">‚úàÔ∏è</div>
    <div class="loading-title">archive.aero</div>
    <div class="loading-progress">
      <div class="loading-progress-bar" id="loadingProgressBar"></div>
    </div>
    <div class="loading-status" id="loadingStatus">Initializing...</div>
  </div>

  <!-- Header Bar -->
  <div class="header-bar">
    <div class="header-content">
      <a href="/" class="site-logo">
        ‚úàÔ∏è archive.aero
      </a>
      <span class="site-tagline">Historical Aviation Charts</span>
      <a href="https://buymeacoffee.com/ryanhemenway" target="_blank" rel="noopener" class="donate-btn" title="Support this project">
        ‚òï Support
      </a>
    </div>

    <!-- Search Box -->
    <div class="search-container">
      <input type="text" class="search-input" id="locationSearch" placeholder="Search location...">
      <span class="search-icon">üîç</span>
    </div>

    <div class="header-actions">
      <!-- Map Tools -->
      <div class="btn-group">
        <button class="icon-btn" id="mapToolsBtn" title="Map Tools" aria-label="Open map tools panel">üõ†Ô∏è</button>
        <button class="icon-btn" id="chartInfoBtn" title="Chart Info" aria-label="View chart information">üìã</button>
      </div>
      <div class="btn-separator"></div>
      <!-- View Controls -->
      <div class="btn-group">
        <button class="icon-btn" id="shareBtn" title="Share (S)" aria-label="Share current view">üîó</button>
        <button class="icon-btn" id="fullscreenBtn" title="Fullscreen (F)">‚õ∂</button>
        <button class="icon-btn" id="helpBtn" title="Keyboard Shortcuts (?)">?</button>
      </div>
      <div class="btn-separator"></div>
      <!-- External Links -->
      <div class="btn-group">
        <a href="https://ryanhemenway.com" target="_blank" rel="noopener" class="icon-btn" title="About Me">üë®‚Äç‚úàÔ∏è</a>
        <a href="https://github.com/hemenway/AeroMap" target="_blank" rel="noopener" class="icon-btn" title="View on GitHub">
          <svg width="18" height="18" viewBox="0 0 16 16" fill="currentColor">
            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
          </svg>
        </a>
      </div>
    </div>
  </div>

  <!-- Opacity Control -->
  <div class="opacity-control" id="opacityControl">
    <h4>Chart Opacity</h4>
    <input type="range" class="opacity-slider" id="opacitySlider" min="0" max="100" value="100">
    <div class="opacity-value"><span id="opacityValue">100</span>%</div>
  </div>

  <!-- Map Tools Panel -->
  <div class="map-tools-panel" id="mapToolsPanel">
    <h4>üõ†Ô∏è Map Tools</h4>

    <div class="tool-section">
      <span class="tool-label">Chart Opacity</span>
      <div class="tool-slider-container">
        <input type="range" class="tool-slider" id="toolOpacitySlider" min="0" max="100" value="100">
        <div class="tool-value"><span id="toolOpacityValue">100</span>%</div>
      </div>
    </div>

    <div class="tool-section">
      <span class="tool-label">My Location</span>
      <button class="tool-button" id="locateBtn">
        <span>Center Map</span>
        <span>üß≠</span>
      </button>
    </div>

    <div class="tool-section">
      <span class="tool-label">Split View</span>
      <button class="tool-button" id="toolCompareBtn">
        <span>Side-by-Side</span>
        <span>‚ó´</span>
      </button>
    </div>
  </div>

  <!-- Share Panel -->
  <div class="share-panel" id="sharePanel" role="dialog" aria-labelledby="sharePanelTitle">
    <h4 id="sharePanelTitle">Share This View</h4>
    <div class="share-url-box">
      <input type="text" class="share-url" id="shareUrl" readonly aria-label="Share URL">
      <button class="copy-btn" id="copyBtn">Copy</button>
    </div>
    <div class="share-info">Share your current timeframe and map position</div>
  </div>

  <!-- Chart Info Panel -->
  <div class="chart-info-panel" id="chartInfoPanel" role="dialog" aria-labelledby="chartInfoTitle">
    <h4 id="chartInfoTitle">üìã Chart Information</h4>
    <div class="chart-info-row">
      <span class="chart-info-label">Date</span>
      <span class="chart-info-value" id="chartInfoDate">‚Äî</span>
    </div>
    <div class="chart-info-row">
      <span class="chart-info-label">Type</span>
      <span class="chart-info-value"><span class="chart-badge sectional">Sectional</span></span>
    </div>
    <div class="chart-info-row">
      <span class="chart-info-label">Format</span>
      <span class="chart-info-value">PMTiles / WebP</span>
    </div>
    <div class="chart-info-row">
      <span class="chart-info-label">Total Charts</span>
      <span class="chart-info-value" id="chartInfoTotal">‚Äî</span>
    </div>
    <div class="chart-info-row">
      <span class="chart-info-label">Status</span>
      <span class="chart-badge historical">Historical Only</span>
    </div>
  </div>

  <!-- Keyboard Shortcuts Overlay -->
  <div class="shortcuts-overlay" id="shortcutsOverlay">
    <div class="shortcuts-content">
      <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
      <div class="shortcut-item">
        <span class="shortcut-desc">Next timeframe</span>
        <span class="shortcut-key">‚Üí</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Previous timeframe</span>
        <span class="shortcut-key">‚Üê</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Play/Pause animation</span>
        <span class="shortcut-key">Space</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Toggle fullscreen</span>
        <span class="shortcut-key">F</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Share current view</span>
        <span class="shortcut-key">S</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Show this help</span>
        <span class="shortcut-key">?</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Close overlay</span>
        <span class="shortcut-key">Esc</span>
      </div>
      <button class="close-shortcuts" id="closeShortcuts">Close</button>
    </div>
  </div>

  <!-- Warning Banner -->
  <div class="warning-overlay" id="warningOverlay">
    <div class="warning-modal">
      <span class="warning-icon">‚ö†Ô∏è</span>
      <p class="warning-text">
        Historical charts only. Do not use for navigation.
      </p>
    </div>
  </div>

  <div id="map"></div>
  <div id="map2"></div>

  <!-- Sources Link -->
  <a href="sources.html" class="sources-link">Sources & Attribution</a>

  <div class="map2-controls">
    <input type="date" id="map2TimeSelect" class="time-select" aria-label="Select comparison timeframe">
  </div>

  <div class="toast" id="toast"></div>

  <div class="ui-layer">
    <div class="controls-card">
      <div class="jog-controls">
        <button class="btn-nav" id="prevBtn" title="Previous Timeframe (‚Üê)" aria-label="Previous timeframe">‚Üê</button>
        <button class="btn-play" id="playBtn" title="Play/Pause (Space)" aria-label="Play or pause animation">‚ñ∂</button>
        <button class="btn-nav" id="nextBtn" title="Next Timeframe (‚Üí)" aria-label="Next timeframe">‚Üí</button>
      </div>

      <div class="speed-control" role="group" aria-label="Animation speed">
        <button class="speed-btn" data-speed="0.5" title="Half speed">¬Ω√ó</button>
        <button class="speed-btn active" data-speed="1" title="Normal speed" aria-pressed="true">1√ó</button>
        <button class="speed-btn" data-speed="2" title="Double speed">2√ó</button>
      </div>

      <div class="loader" id="loader" role="status" aria-label="Loading"></div>

      <div class="timeline-track-wrapper" id="trackWrapper">
        <div class="timeline-track">
          <div class="timeline-progress" id="progress"></div>
          <div id="ticksContainer"></div>
          <div class="handle" id="handle"></div>
        </div>
      </div>

      <div class="info-panel">
        <input type="date" id="timeSelect" class="time-select" aria-label="Select timeframe">
        <div class="label-sub" id="lblRange">Timeline</div>
      </div>
    </div>


  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js"></script>

  <script>
    // Guard against Leaflet tile callbacks firing after a layer was removed
    if (L && L.TileLayer && L.TileLayer.prototype._tileReady) {
      const originalTileReady = L.TileLayer.prototype._tileReady;
      L.TileLayer.prototype._tileReady = function(error, tile) {
        if (!this._map) return;
        return originalTileReady.call(this, error, tile);
      };
    }

    /** CONFIGURATION **/
    const CONFIG = {
      baseUrl: 'https://data.archive.aero/sectionals/pmtiles/',
      csvUrl: 'dates.csv', // Dynamic Source
      initialView: { center: [32.7767, -96.7970], zoom: 10 },
      frames: [] // Will be populated dynamically
    };

    /** UTILITIES **/
    const Utils = {
      buildPMTilesUrl: (date, customUrl) => {
        if (customUrl) return customUrl;
        return `${CONFIG.baseUrl}${date}.pmtiles`;
      },
      toast: (msg, duration = 3000) => {
        const el = document.getElementById('toast');
        if (el) {
          el.textContent = msg;
          el.classList.add('visible');
          setTimeout(() => el.classList.remove('visible'), duration);
        }
      },
      formatDateId: (dateStr) => {
        try {
          const [y, m, d] = dateStr.split('-').map(Number);
          const date = new Date(y, m - 1, d);
          return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
        } catch (e) {
          return dateStr;
        }
      },
      toggleFullscreen: () => {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(err => {
            Utils.toast(`Error entering fullscreen: ${err.message}`);
          });
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        }
      },
      debounce: (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
    };

    /** DATA LOADER **/
    async function loadData() {
      return new Promise((resolve, reject) => {
        Papa.parse(CONFIG.csvUrl, {
          download: true,
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            try {
              const frames = [];
              results.data.forEach(row => {
                if (!row.date_iso || row.date_iso === '?') return;
                frames.push({
                  id: Utils.formatDateId(row.date_iso),
                  date: row.date_iso,
                  url: row.url || null
                });
              });
              CONFIG.frames = frames.sort((a, b) => {
                return new Date(a.date) - new Date(b.date);
              });
              resolve();
            } catch (e) {
              console.error("Data processing error", e);
              Utils.toast("Error processing CSV data");
              reject(e);
            }
          },
          error: (err) => {
            console.error("CSV Load Error", err);
            Utils.toast("Failed to load timeline data");
            reject(err);
          }
        });
      });
    }

    /** MAP CONTROLLER **/
    class MapController {
      constructor(mapId) {
        this.map = L.map(mapId, {
          zoomControl: false,
          fadeAnimation: true,
          zoomAnimation: true,
          attributionControl: true
        }).setView(CONFIG.initialView.center, CONFIG.initialView.zoom);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 20, opacity: 1, zIndex: 1,
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &middot; &copy; <a href="https://carto.com/attributions">CARTO</a>'
        }).addTo(this.map);

        L.control.zoom({ position: 'topright' }).addTo(this.map);

        this.cache = {};
        this.activeLayers = [];
        this.pmtilesInstances = {}; // Cache for PMTiles instances
        this.requestCounter = 0; // Track most recent frame request

        // Debounced version of showFrame for timeline scrubbing
        this.showFrameDebounced = Utils.debounce(this.showFrame.bind(this), 250);
      }

      getLayerData(date, customUrl) {
        if (this.cache[date]) return this.cache[date];

        const pmtilesUrl = Utils.buildPMTilesUrl(date, customUrl);

        // Create a PMTiles-backed raster tile layer
        // Using the pmtiles library to create a tile source
        const p = new pmtiles.PMTiles(pmtilesUrl);
        this.pmtilesInstances[date] = p;

        // Create a Leaflet tile layer that fetches from PMTiles
        const layer = L.tileLayer('', {
          minZoom: 0,
          maxZoom: 18,
          minNativeZoom: 0,
          maxNativeZoom: 11,  // Tiles generated up to zoom 11, Leaflet will scale beyond
          tileSize: 256,
          opacity: 0,
          zIndex: 10,
          keepBuffer: 2,
          updateWhenIdle: true,
          updateWhenZooming: false
        });

        // Override the getTileUrl method to use PMTiles
        layer.createTile = function(coords, done) {
          const tile = document.createElement('img');
          tile.alt = '';
          tile.setAttribute('role', 'presentation');

          p.getZxy(coords.z, coords.x, coords.y).then(result => {
            // If layer was removed before data arrived, abort
            if (!layer._map) return;

            if (result && result.data) {
              const blob = new Blob([result.data], { type: 'image/webp' });
              tile.src = URL.createObjectURL(blob);
              tile.onload = () => {
                URL.revokeObjectURL(tile.src);
                // Skip callback if layer is no longer on a map to avoid Leaflet null _map errors
                if (!layer._map) return;
                done(null, tile);
              };
              tile.onerror = () => {
                if (!layer._map) return;
                done(new Error('Tile load error'), tile);
              };
            } else {
              // No tile data - return transparent tile
              tile.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
              if (!layer._map) return;
              done(null, tile);
            }
          }).catch(err => {
            // Return transparent tile on error
            tile.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
            if (!layer._map) return;
            done(null, tile);
          });

          return tile;
        };

        this.cache[date] = { layer };
        return this.cache[date];
      }


      waitForLayer(layer) {
        return new Promise(resolve => {
          if (layer._tiles && Object.keys(layer._tiles).length > 0) return resolve();
          const onload = () => { layer.off('load', onload); resolve(); };
          layer.on('load', onload);
          setTimeout(() => { layer.off('load', onload); resolve(); }, 2000);
        });
      }

      async showFrame(index) {
        const currentFrame = CONFIG.frames[index];
        const loader = document.getElementById('loader');
        const spinnerTimeout = setTimeout(() => loader.classList.add('active'), 100);
        const requestId = ++this.requestCounter;

        // Get layer for the selected date only
        const data = this.getLayerData(currentFrame.date, currentFrame.url);
        if (!data || !data.layer) {
          clearTimeout(spinnerTimeout);
          loader.classList.remove('active');
          return;
        }

        const newLayer = data.layer;
        newLayer.setZIndex(10);
        const oldLayers = [...this.activeLayers];
        const opacityValue = parseFloat(document.getElementById('toolOpacitySlider')?.value || 100) / 100;

        // If we're already displaying this layer, just sync opacity and return
        if (this.activeLayers[0] === newLayer) {
          newLayer.setOpacity(opacityValue);
          clearTimeout(spinnerTimeout);
          loader.classList.remove('active');
          return;
        }

        // Add new layer at opacity 0 (hidden)
        if (!this.map.hasLayer(newLayer)) {
          newLayer.setOpacity(0);
          newLayer.addTo(this.map);
        }

        const tilesReady = () => {
          const tiles = newLayer._tiles;
          return tiles && Object.keys(tiles).length > 0 && Object.values(tiles).every(t => t.loaded);
        };

        const stopSpinner = () => {
          clearTimeout(spinnerTimeout);
          loader.classList.remove('active');
        };

        const removeIfInactive = () => {
          if (!this.activeLayers.includes(newLayer) && this.map.hasLayer(newLayer)) {
            this.map.removeLayer(newLayer);
          }
        };

        const finalizeSwap = () => {
          // Ignore stale requests
          if (requestId !== this.requestCounter) {
            removeIfInactive();
            stopSpinner();
            return;
          }

          requestAnimationFrame(() => {
            newLayer.setOpacity(opacityValue);
            oldLayers.forEach(l => { if (l !== newLayer && this.map.hasLayer(l)) this.map.removeLayer(l); });
            this.activeLayers = [newLayer];
            stopSpinner();
          });
        };

        const bailOut = (notify = true) => {
          if (requestId !== this.requestCounter) {
            removeIfInactive();
            stopSpinner();
            return;
          }
          removeIfInactive();
          stopSpinner();
          if (notify) Utils.toast('Chart failed to load; keeping previous map');
        };

        const cleanupListeners = (onLoadFn, onErrorFn) => {
          newLayer.off('load', onLoadFn);
          newLayer.off('tileerror', onErrorFn);
        };

        // If tiles already cached and ready, swap immediately
        if (tilesReady()) {
          finalizeSwap();
        } else {
          const onLoad = () => {
            cleanupListeners(onLoad, onError);
            finalizeSwap();
          };

          const onError = () => {
            cleanupListeners(onLoad, onError);
            bailOut();
          };

          newLayer.on('load', onLoad);
          newLayer.on('tileerror', onError);

          // Fallback: if layer still isn't ready after timeout, keep current map to avoid flicker
          setTimeout(() => {
            cleanupListeners(onLoad, onError);
            if (tilesReady()) {
              finalizeSwap();
            } else {
              bailOut(false);
            }
          }, 10000);
        }

        // Preload 3 frames before and 3 after, clean up others
        this.manageCache(index);
      }

      manageCache(currentIndex) {
        const BUFFER = 3; // Keep 3 before and 3 after
        const totalFrames = CONFIG.frames.length;

        // Calculate which indices to keep
        const keepIndices = new Set();
        for (let offset = -BUFFER; offset <= BUFFER; offset++) {
          let idx = currentIndex + offset;
          // Wrap around for circular navigation
          if (idx < 0) idx = totalFrames + idx;
          if (idx >= totalFrames) idx = idx - totalFrames;
          keepIndices.add(idx);
        }

        // Preload frames in the buffer
        keepIndices.forEach(idx => {
          if (idx !== currentIndex) {
            const frame = CONFIG.frames[idx];
            // Just create the layer data (doesn't add to map)
            this.getLayerData(frame.date, frame.url);
          }
        });

        // Clean up frames outside the buffer
        const frameDates = CONFIG.frames.map(f => f.date);
        Object.keys(this.cache).forEach(date => {
          const frameIndex = frameDates.indexOf(date);
          if (frameIndex !== -1 && !keepIndices.has(frameIndex)) {
            const cached = this.cache[date];
            // Remove layer from map if mounted
            if (cached.layer && this.map.hasLayer(cached.layer)) {
              this.map.removeLayer(cached.layer);
            }
            // Clean up PMTiles instance
            if (this.pmtilesInstances[date]) {
              delete this.pmtilesInstances[date];
            }
            // Remove from cache
            delete this.cache[date];
          }
        });
      }

      setOpacity(opacity) {
        this.activeLayers.forEach(layer => layer.setOpacity(opacity));
      }
    }

    /** TIMELINE CONTROLLER **/
    class TimelineApp {
      constructor(mapController) {
        this.mapCtrl = mapController;
        this.frames = CONFIG.frames;

        const dates = this.frames.map(f => new Date(f.date).getTime());
        const min = Math.min(...dates);
        const max = Math.max(...dates);
        this.frames.forEach((f, i) => { const d = dates[i]; f.pct = max === min ? 0 : ((d - min) / (max - min)) * 100; });

        this.currentIndex = 0;
        this.isPlaying = false;
        this.playInterval = null;
        this.playbackSpeed = 1;

        this.ui = {
          prevBtn: document.getElementById('prevBtn'),
          nextBtn: document.getElementById('nextBtn'),
          playBtn: document.getElementById('playBtn'),
          progress: document.getElementById('progress'),
          handle: document.getElementById('handle'),
          track: document.getElementById('trackWrapper'),
          timeSelect: document.getElementById('timeSelect'),
          lblRange: document.getElementById('lblRange'),
          ticks: document.getElementById('ticksContainer')
        };

        this.initUI();
        this.initControls();
        this.update(this.frames.length - 1); // Start at most recent

        window.addEventListener('keydown', (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

          if (e.key === 'ArrowRight') this.step(1);
          if (e.key === 'ArrowLeft') this.step(-1);
          if (e.key === ' ') {
            e.preventDefault();
            this.togglePlay();
          }
          if (e.key === 'f' || e.key === 'F') {
            e.preventDefault();
            Utils.toggleFullscreen();
          }
          if (e.key === 's' || e.key === 'S') {
            e.preventDefault();
            const sharePanel = document.getElementById('sharePanel');
            const wasVisible = sharePanel.classList.contains('visible');
            this.hideAllPanels();
            if (!wasVisible) {
              this.updateShareUrl();
              sharePanel.classList.add('visible');
            }
          }
          if (e.key === '?') {
            e.preventDefault();
            document.getElementById('shortcutsOverlay').classList.add('visible');
          }
          if (e.key === 'Escape') {
            document.getElementById('shortcutsOverlay').classList.remove('visible');
            this.hideAllPanels();
          }
        });
      }

      initControls() {
        // Help button
        document.getElementById('helpBtn')?.addEventListener('click', () => {
          document.getElementById('shortcutsOverlay').classList.add('visible');
          this.hideAllPanels(['shortcutsOverlay']);
        });

        document.getElementById('closeShortcuts')?.addEventListener('click', () => {
          document.getElementById('shortcutsOverlay').classList.remove('visible');
        });

        document.getElementById('shortcutsOverlay')?.addEventListener('click', (e) => {
          if (e.target.id === 'shortcutsOverlay') {
            document.getElementById('shortcutsOverlay').classList.remove('visible');
          }
        });

        // Fullscreen button
        document.getElementById('fullscreenBtn')?.addEventListener('click', () => {
          Utils.toggleFullscreen();
        });

        // Map Tools Panel
        const mapToolsBtn = document.getElementById('mapToolsBtn');
        const mapToolsPanel = document.getElementById('mapToolsPanel');
        const toolOpacitySlider = document.getElementById('toolOpacitySlider');
        const toolOpacityValue = document.getElementById('toolOpacityValue');

        mapToolsBtn?.addEventListener('click', () => {
          const wasVisible = mapToolsPanel.classList.contains('visible');
          this.hideAllPanels();
          if (!wasVisible) mapToolsPanel.classList.add('visible');
        });

        toolOpacitySlider?.addEventListener('input', (e) => {
          const value = e.target.value;
          toolOpacityValue.textContent = value;
          this.mapCtrl.setOpacity(value / 100);
          // Sync with old opacity slider if it exists
          const oldOpacitySlider = document.getElementById('opacitySlider');
          const oldOpacityValue = document.getElementById('opacityValue');
          if (oldOpacitySlider) oldOpacitySlider.value = value;
          if (oldOpacityValue) oldOpacityValue.textContent = value;
        });

        // Legacy Opacity control (keep for backward compatibility)
        const opacityBtn = document.getElementById('opacityBtn');
        const opacityControl = document.getElementById('opacityControl');
        const opacitySlider = document.getElementById('opacitySlider');
        const opacityValue = document.getElementById('opacityValue');

        opacityBtn?.addEventListener('click', () => {
          const wasVisible = opacityControl.classList.contains('visible');
          this.hideAllPanels();
          if (!wasVisible) opacityControl.classList.add('visible');
        });

        opacitySlider?.addEventListener('input', (e) => {
          const value = e.target.value;
          opacityValue.textContent = value;
          this.mapCtrl.setOpacity(value / 100);
          // Sync with new tool slider
          if (toolOpacitySlider) toolOpacitySlider.value = value;
          if (toolOpacityValue) toolOpacityValue.textContent = value;
        });

        // Share button
        const shareBtn = document.getElementById('shareBtn');
        const sharePanel = document.getElementById('sharePanel');
        const shareUrl = document.getElementById('shareUrl');
        const copyBtn = document.getElementById('copyBtn');

        shareBtn?.addEventListener('click', () => {
          const wasVisible = sharePanel.classList.contains('visible');
          this.hideAllPanels();
          if (!wasVisible) {
            this.updateShareUrl();
            sharePanel.classList.add('visible');
          }
        });

        copyBtn?.addEventListener('click', async () => {
          try {
            await navigator.clipboard.writeText(shareUrl.value);
            copyBtn.textContent = '‚úì Copied';
            copyBtn.classList.add('copied');
            setTimeout(() => {
              copyBtn.textContent = 'Copy';
              copyBtn.classList.remove('copied');
            }, 2000);
          } catch (err) {
            // Fallback for browsers without clipboard API support
            try {
              shareUrl.select();
              shareUrl.setSelectionRange(0, 99999); // For mobile devices
              const success = document.execCommand('copy');
              if (success) {
                copyBtn.textContent = '‚úì Copied';
                copyBtn.classList.add('copied');
                setTimeout(() => {
                  copyBtn.textContent = 'Copy';
                  copyBtn.classList.remove('copied');
                }, 2000);
              } else {
                Utils.toast('Please manually copy the URL');
              }
            } catch (fallbackErr) {
              Utils.toast('Please manually copy the URL');
            }
          }
        });

        // Play button
        this.ui.playBtn?.addEventListener('click', () => {
          this.togglePlay();
        });

        // Speed Control
        const speedBtns = document.querySelectorAll('.speed-btn');
        speedBtns.forEach(btn => {
          btn.addEventListener('click', () => {
            const speed = parseFloat(btn.dataset.speed);
            this.playbackSpeed = speed;

            // Update active state and aria-pressed
            speedBtns.forEach(b => {
              b.classList.remove('active');
              b.setAttribute('aria-pressed', 'false');
            });
            btn.classList.add('active');
            btn.setAttribute('aria-pressed', 'true');

            // Update interval if playing
            if (this.isPlaying && this.playInterval) {
              clearInterval(this.playInterval);
              this.playInterval = setInterval(() => {
                this.step(1);
              }, 2000 / this.playbackSpeed);
            }
          });
        });

        // Chart Info Panel
        const chartInfoBtn = document.getElementById('chartInfoBtn');
        const chartInfoPanel = document.getElementById('chartInfoPanel');

        chartInfoBtn?.addEventListener('click', () => {
          const wasVisible = chartInfoPanel.classList.contains('visible');
          this.hideAllPanels();
          if (!wasVisible) chartInfoPanel.classList.add('visible');
        });
      }

      hideAllPanels(except = []) {
        const panels = ['opacityControl', 'sharePanel', 'mapToolsPanel', 'chartInfoPanel'];
        panels.forEach(id => {
          if (!except.includes(id)) {
            document.getElementById(id)?.classList.remove('visible');
          }
        });
      }

      updateShareUrl() {
        const frame = this.frames[this.currentIndex];
        const center = this.mapCtrl.map.getCenter();
        const zoom = this.mapCtrl.map.getZoom();
        const url = `${window.location.origin}${window.location.pathname}?date=${frame.date}&lat=${center.lat.toFixed(4)}&lng=${center.lng.toFixed(4)}&zoom=${zoom}`;
        document.getElementById('shareUrl').value = url;
      }

      togglePlay() {
        this.isPlaying = !this.isPlaying;
        const playBtn = this.ui.playBtn;

        if (this.isPlaying) {
          playBtn.textContent = '‚è∏';
          playBtn.title = 'Pause (Space)';
          playBtn.setAttribute('aria-label', 'Pause animation');
          this.playInterval = setInterval(() => {
            this.step(1);
          }, 2000 / this.playbackSpeed);
        } else {
          playBtn.textContent = '‚ñ∂';
          playBtn.title = 'Play (Space)';
          playBtn.setAttribute('aria-label', 'Play animation');
          if (this.playInterval) {
            clearInterval(this.playInterval);
            this.playInterval = null;
          }
        }
      }

      initUI() {
        this.ui.lblRange.textContent = `${this.frames[0].id} ‚Äî ${this.frames[this.frames.length - 1].id}`;

        // Setup date picker with min/max and default to most recent
        const firstDate = this.frames[0].date;
        const lastDate = this.frames[this.frames.length - 1].date;
        this.ui.timeSelect.min = firstDate;
        this.ui.timeSelect.max = lastDate;
        this.ui.timeSelect.value = lastDate; // Default to most recent

        // Start at most recent frame
        this.currentIndex = this.frames.length - 1;

        this.ui.timeSelect.addEventListener('change', () => {
          const selectedDate = this.ui.timeSelect.value;
          if (!selectedDate) return;

          // Find the most recent frame on or before the selected date (never round forward)
          const selectedTime = new Date(selectedDate).getTime();
          let bestIdx = 0;
          let bestTime = -Infinity;

          this.frames.forEach((f, i) => {
            const frameTime = new Date(f.date).getTime();
            // Only consider dates on or before selected date
            if (frameTime <= selectedTime && frameTime > bestTime) {
              bestTime = frameTime;
              bestIdx = i;
            }
          });

          // If no date found on or before (user selected before earliest), use the first frame
          if (bestTime === -Infinity) {
            bestIdx = 0;
          }

          this.update(bestIdx);
        });

        // ticks with year labels
        const years = new Set();
        this.frames.forEach((f, i) => {
          const tick = document.createElement('div');
          tick.className = 'tick';
          tick.style.left = `${f.pct}%`;

          // Extract year from date
          const year = f.date.split('-')[0];

          // Mark as major tick if it's a new year or every 5th year
          if (!years.has(year)) {
            years.add(year);
            const yearNum = parseInt(year);
            if (yearNum % 5 === 0 || i === 0 || i === this.frames.length - 1) {
              tick.classList.add('major');
              const label = document.createElement('div');
              label.className = 'tick-label';
              label.textContent = year;
              tick.appendChild(label);
            }
          }

          this.ui.ticks.appendChild(tick);
        });

        // Jog Controls
        this.ui.prevBtn.onclick = () => this.step(-1);
        this.ui.nextBtn.onclick = () => this.step(1);

        // drag on the track/handle
        const handleInput = (clientX) => {
          const rect = this.ui.track.getBoundingClientRect();
          const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
          const pct = (x / rect.width) * 100;

          let closestIdx = 0, minDiff = Infinity;
          this.frames.forEach((f, i) => {
            const diff = Math.abs(f.pct - pct);
            if (diff < minDiff) { minDiff = diff; closestIdx = i; }
          });

          if (closestIdx !== this.currentIndex) this.update(closestIdx, true);
        };

        let isDragging = false;
        const startDrag = (e) => {
          isDragging = true;
          handleInput((e.touches?.[0]?.clientX) ?? e.clientX);
        };
        const moveDrag = (e) => { if (isDragging) handleInput((e.touches?.[0]?.clientX) ?? e.clientX); };
        const endDrag = () => { isDragging = false; };

        this.ui.track.addEventListener('mousedown', startDrag);
        this.ui.track.addEventListener('touchstart', startDrag, { passive: false });
        window.addEventListener('mousemove', moveDrag);
        window.addEventListener('touchmove', moveDrag, { passive: false });
        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);
      }

      update(index, lazy = false) {
        this.currentIndex = index;
        const f = this.frames[index];

        // Update date picker to show the current frame's date
        if (this.ui.timeSelect && this.ui.timeSelect.value !== f.date) {
          this.ui.timeSelect.value = f.date;
        }

        this.ui.handle.style.left = `${f.pct}%`;
        this.ui.progress.style.width = `${f.pct}%`;

        Array.from(this.ui.ticks.children).forEach((tick, i) => {
          if (i === index) tick.classList.add('active'); else tick.classList.remove('active');
        });

        if (lazy) {
          this.mapCtrl.showFrameDebounced(index);
        } else {
          this.mapCtrl.showFrame(index);
        }
      }

      step(dir) {
        let next = this.currentIndex + dir;
        if (next >= this.frames.length) next = 0;
        if (next < 0) next = this.frames.length - 1;
        this.update(next);
      }
    }

    // Initialize Application
    async function initApp() {
      // Loading progress elements
      const loadingSplash = document.getElementById('loadingSplash');
      const loadingProgressBar = document.getElementById('loadingProgressBar');
      const loadingStatus = document.getElementById('loadingStatus');

      const updateLoading = (percent, status) => {
        loadingProgressBar.style.width = `${percent}%`;
        loadingStatus.textContent = status;
      };

      updateLoading(10, 'Loading timeline data...');

      // Show warning banner temporarily
      const warningOverlay = document.getElementById('warningOverlay');
      setTimeout(() => warningOverlay.classList.add('visible'), 1500);
      setTimeout(() => warningOverlay.classList.remove('visible'), 8000);

      await loadData(); // Fetch and parse CSV first
      updateLoading(40, 'Initializing map...');

      if (CONFIG.frames.length === 0) {
        Utils.toast("No valid frames found in CSV");
        loadingSplash.classList.add('hidden');
        return;
      }

      const mapCtrl = new MapController('map');
      updateLoading(70, 'Loading controls...');

      const timelineApp = new TimelineApp(mapCtrl);
      updateLoading(90, 'Almost ready...');

      // Handle URL parameters for shared links
      const urlParams = new URLSearchParams(window.location.search);
      const dateParam = urlParams.get('date');
      const latParam = urlParams.get('lat');
      const lngParam = urlParams.get('lng');
      const zoomParam = urlParams.get('zoom');

      // Set map position from URL if available
      if (latParam && lngParam && zoomParam) {
        const lat = parseFloat(latParam);
        const lng = parseFloat(lngParam);
        const zoom = parseInt(zoomParam);
        if (!isNaN(lat) && !isNaN(lng) && !isNaN(zoom)) {
          mapCtrl.map.setView([lat, lng], zoom);
        }
      }

      // Set timeframe from URL if available
      if (dateParam) {
        const frameIndex = CONFIG.frames.findIndex(f => f.date === dateParam);
        if (frameIndex >= 0) {
          timelineApp.update(frameIndex);
        }
      }

      // Location Search & Silent IP Geolocation
      const searchInput = document.getElementById('locationSearch');

      // Auto-locate via IP if no URL params
      if (!latParam && !lngParam) {
        try {
          // Use ipapi.co - secure HTTPS endpoint
          fetch('https://ipapi.co/json/')
            .then(res => res.json())
            .then(data => {
              if (data && data.latitude && data.longitude) {
                // Silent move, no toast
                mapCtrl.map.flyTo([data.latitude, data.longitude], 10, { duration: 2.0 });
              }
            })
            .catch(e => {
              console.log('IP Geo failed', e);
              // Fallback: show a subtle hint that geolocation failed
              Utils.toast('Unable to detect location', 2000);
            });
        } catch (e) {
          console.log('IP Geo Error', e);
        }
      }

      // Location Crosshair Button - Request User's Geolocation
      const locateBtn = document.getElementById('locateBtn');
      locateBtn?.addEventListener('click', () => {
        if ('geolocation' in navigator) {
          Utils.toast('Getting your location...');
          navigator.geolocation.getCurrentPosition(
            (position) => {
              const lat = position.coords.latitude;
              const lng = position.coords.longitude;
              mapCtrl.map.flyTo([lat, lng], 10, { duration: 1.5 });
              Utils.toast('Centered on your location');
            },
            (error) => {
              console.error('Geolocation error:', error);
              let message = 'Unable to get your location';
              if (error.code === error.PERMISSION_DENIED) {
                message = 'Location permission denied';
              } else if (error.code === error.POSITION_UNAVAILABLE) {
                message = 'Location unavailable';
              } else if (error.code === error.TIMEOUT) {
                message = 'Location request timed out';
              }
              Utils.toast(message);
            },
            {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 0
            }
          );
        } else {
          Utils.toast('Geolocation not supported by your browser');
        }
      });

      // Search Handler with rate limiting
      let lastSearchTime = 0;
      const SEARCH_COOLDOWN = 1000; // 1 second between searches

      if (searchInput) {
        searchInput.addEventListener('keydown', async (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const query = searchInput.value.trim();
            if (!query) return;

            // Rate limiting check
            const now = Date.now();
            if (now - lastSearchTime < SEARCH_COOLDOWN) {
              Utils.toast("Please wait before searching again");
              return;
            }
            lastSearchTime = now;

            try {
              Utils.toast("Searching...");
              // Use Nominatim geocoding API
              const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}`);
              const data = await res.json();

              if (data && data.length > 0) {
                const best = data[0];
                const lat = parseFloat(best.lat);
                const lon = parseFloat(best.lon);
                mapCtrl.map.flyTo([lat, lon], 10, { duration: 1.5 });
                searchInput.blur();
                Utils.toast(`Found: ${best.display_name.split(',')[0]}`);
              } else {
                Utils.toast("Location not found");
              }
            } catch (err) {
              console.error('Search error:', err);
              Utils.toast("Search failed - try again");
            }
          }
        });
      } else {
        console.error('Search input element not found');
      }

      // --- Side-by-Side Comparison Logic ---
      const mapCtrl2 = new MapController('map2');
      const compareBtn = document.getElementById('compareBtn'); // Old location (if exists)
      const toolCompareBtn = document.getElementById('toolCompareBtn'); // New location in map tools
      const map2Controls = document.querySelector('.map2-controls');
      const map2TimeSelect = document.getElementById('map2TimeSelect');
      let isCompareMode = false;
      let isSyncing = false;

      // Setup Map 2 date picker
      const firstDate = CONFIG.frames[0].date;
      const lastDate = CONFIG.frames[CONFIG.frames.length - 1].date;
      map2TimeSelect.min = firstDate;
      map2TimeSelect.max = lastDate;
      map2TimeSelect.value = lastDate;

      map2TimeSelect.addEventListener('change', () => {
        const selectedDate = map2TimeSelect.value;
        if (!selectedDate) return;

        // Find the most recent frame on or before the selected date (never round forward)
        const selectedTime = new Date(selectedDate).getTime();
        let bestIdx = 0;
        let bestTime = -Infinity;

        CONFIG.frames.forEach((f, i) => {
          const frameTime = new Date(f.date).getTime();
          if (frameTime <= selectedTime && frameTime > bestTime) {
            bestTime = frameTime;
            bestIdx = i;
          }
        });

        // If no date found on or before, use the first frame
        if (bestTime === -Infinity) {
          bestIdx = 0;
        }

        // Update picker to show the actual available date
        map2TimeSelect.value = CONFIG.frames[bestIdx].date;
        mapCtrl2.showFrame(bestIdx);
      });

      // Sync Maps Function with debouncing to prevent infinite loops
      let syncTimeout = null;
      function syncMaps(source, target) {
        if (!isCompareMode || isSyncing) return;
        isSyncing = true;

        // Clear any pending sync timeout
        if (syncTimeout) {
          clearTimeout(syncTimeout);
        }

        target.setView(source.getCenter(), source.getZoom(), { animate: false });

        // Reset flag after a short delay to ensure all events are processed
        syncTimeout = setTimeout(() => {
          isSyncing = false;
          syncTimeout = null;
        }, 50);
      }

      mapCtrl.map.on('moveend', () => syncMaps(mapCtrl.map, mapCtrl2.map));
      mapCtrl2.map.on('moveend', () => syncMaps(mapCtrl2.map, mapCtrl.map));

      // Toggle Compare Mode Function
      function toggleCompareMode() {
        isCompareMode = !isCompareMode;
        document.body.classList.toggle('split-view', isCompareMode);

        // Update both button states if they exist
        if (compareBtn) compareBtn.classList.toggle('active', isCompareMode);
        if (toolCompareBtn) toolCompareBtn.classList.toggle('active', isCompareMode);

        // Resize maps
        mapCtrl.map.invalidateSize();
        mapCtrl2.map.invalidateSize();

        if (isCompareMode) {
          // Init Map 2 state if needed
          const currentIdx = timelineApp.currentIndex;
          // Default map 2 to either same or previous frame
          let compareIdx = currentIdx > 0 ? currentIdx - 1 : currentIdx;
          map2TimeSelect.value = CONFIG.frames[compareIdx].date;
          mapCtrl2.showFrame(compareIdx);

          // Sync view to Map 1 immediately
          mapCtrl2.map.setView(mapCtrl.map.getCenter(), mapCtrl.map.getZoom(), { animate: false });

          Utils.toast("Compare Mode: On");
        } else {
          Utils.toast("Compare Mode: Off");
          // Optional: clear map2 layers to save resources? 
          // For now, keep them.
        }
      }

      // Toggle Compare Mode - bind to both buttons
      compareBtn?.addEventListener('click', toggleCompareMode);
      toolCompareBtn?.addEventListener('click', toggleCompareMode);

      // Update chart info panel with initial data
      const chartInfoDate = document.getElementById('chartInfoDate');
      const chartInfoTotal = document.getElementById('chartInfoTotal');
      chartInfoTotal.textContent = CONFIG.frames.length.toString();

      // Update chart info when frame changes
      const originalUpdate = timelineApp.update.bind(timelineApp);
      timelineApp.update = function(index, lazy) {
        originalUpdate(index, lazy);
        const frame = CONFIG.frames[index];
        if (chartInfoDate && frame) {
          chartInfoDate.textContent = Utils.formatDateId(frame.date);
        }
      };

      // Hide loading splash
      updateLoading(100, 'Ready!');
      setTimeout(() => {
        loadingSplash.classList.add('hidden');
      }, 300);
    }

    document.addEventListener('DOMContentLoaded', initApp);
  </script>
</body>

</html>
