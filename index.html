<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>archive.aero - Historical Aeronautical Chart Viewer</title>
  <meta name="description"
    content="Explore historical aeronautical charts and sectional maps. View how aviation charts have evolved over time with AeroMap's interactive timeline viewer." />
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚úàÔ∏è</text></svg>" />

  <!-- Preload critical resources -->
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://data.archive.aero" crossorigin>
  <link rel="preconnect" href="https://basemaps.cartocdn.com" crossorigin>

  <link rel="preload" as="script" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin>
  <link rel="preload" as="script" href="https://unpkg.com/papaparse@5.4.1/papaparse.min.js" crossorigin>
  <link rel="preload" as="script" href="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js" crossorigin>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="styles.css" />

</head>

<body>

  <!-- Loading Splash Screen -->
  <div class="loading-splash" id="loadingSplash" role="status" aria-live="polite">
    <div class="loading-logo" aria-hidden="true">‚úàÔ∏è</div>
    <div class="loading-title">archive.aero</div>
    <div class="loading-progress">
      <div class="loading-progress-bar" id="loadingProgressBar"></div>
    </div>
    <div class="loading-status" id="loadingStatus">Initializing...</div>
  </div>

  <!-- Header Bar -->
  <div class="header-bar">
    <div class="header-content">
      <div class="menu-trigger">
        <button class="menu-toggle site-logo" id="menuToggle" type="button" aria-expanded="false"
          aria-controls="siteMenu" aria-label="Open site menu">
          ‚úàÔ∏è archive.aero
        </button>
        <nav class="menu-panel" id="siteMenu" aria-label="Site menu">
          <a href="https://github.com/hemenway/AeroMap" target="_blank" rel="noopener" class="menu-item">
            <span class="menu-item-icon" aria-hidden="true">
              <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path
                  d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
              </svg>
            </span>
            <span>GitHub</span>
          </a>
        </nav>
      </div>
      <span class="site-tagline">Historical Aviation Charts</span>
    </div>
    <div class="header-right">
      <a href="https://ryanhemenway.com" target="_blank" rel="noopener" class="about-btn" title="About Me">
        üë®‚Äç‚úàÔ∏è About
      </a>
      <a href="https://buymeacoffee.com/ryanhemenway" target="_blank" rel="noopener" class="donate-btn"
        title="Support this project">
        ‚òï Support
      </a>
    </div>
  </div>

  <!-- Tools Dropdown (mounted next to zoom controls) -->
  <div class="tools-control leaflet-control" id="toolsControl">
    <button class="tools-btn" id="toolsBtn" type="button" title="Tools" aria-expanded="false" aria-controls="toolsPanel"
      aria-label="Open tools panel">
      üß∞
    </button>
    <div class="tools-panel" id="toolsPanel" role="dialog" aria-label="Map tools and settings">
      <div class="tools-section collapsible">
        <h4 class="section-header" data-section="mapTools">
          <span>üõ†Ô∏è Map Tools</span>
          <span class="collapse-icon">‚ñº</span>
        </h4>
        <div class="section-content" id="mapToolsContent">
          <div class="tool-section">
            <span class="tool-label">Chart Opacity</span>
            <div class="tool-slider-container">
              <input type="range" class="tool-slider" id="toolOpacitySlider" min="0" max="100" value="100">
              <div class="tool-value"><span id="toolOpacityValue">100</span>%</div>
            </div>
          </div>

          <div class="tool-section">
            <span class="tool-label">My Location</span>
            <button class="tool-button" id="locateBtn">
              <span>Center Map</span>
              <span>üß≠</span>
            </button>
          </div>

          <div class="tool-section">
            <span class="tool-label">Fullscreen</span>
            <button class="tool-button" id="fullscreenBtn">
              <span>Toggle Fullscreen</span>
              <span>‚õ∂</span>
            </button>
          </div>

          <div class="tool-section">
            <span class="tool-label">Shortcuts</span>
            <button class="tool-button" id="helpBtn">
              <span>Keyboard Shortcuts</span>
              <span>?</span>
            </button>
          </div>

        </div>
      </div>

      <div class="tools-section collapsible">
        <h4 class="section-header" data-section="chartInfo">
          <span>üìã Chart Information</span>
          <span class="collapse-icon">‚ñº</span>
        </h4>
        <div class="section-content" id="chartInfoContent">
          <div class="chart-info-row">
            <span class="chart-info-label">Date</span>
            <span class="chart-info-value" id="chartInfoDate">‚Äî</span>
          </div>
          <div class="chart-info-row">
            <span class="chart-info-label">Type</span>
            <span class="chart-info-value"><span class="chart-badge sectional">Sectional</span></span>
          </div>
          <div class="chart-info-row">
            <span class="chart-info-label">Format</span>
            <span class="chart-info-value">PMTiles / WebP</span>
          </div>
          <div class="chart-info-row">
            <span class="chart-info-label">Total Charts</span>
            <span class="chart-info-value" id="chartInfoTotal">‚Äî</span>
          </div>
          <div class="chart-info-row">
            <span class="chart-info-label">Effective Layers</span>
            <span class="chart-info-value" id="chartInfoEffective">‚Äî</span>
          </div>
          <div class="chart-info-row">
            <span class="chart-info-label">Status</span>
            <span class="chart-badge historical">Historical Only</span>
          </div>
          <div class="chart-info-row">
            <span class="chart-info-label">Zoom Level</span>
            <span class="chart-info-value" id="chartInfoZoom">‚Äî</span>
          </div>
        </div>
      </div>

      <div class="tools-section collapsible">
        <h4 class="section-header" data-section="share">
          <span>üîó Share</span>
          <span class="collapse-icon">‚ñº</span>
        </h4>
        <div class="section-content" id="shareContent">
          <div class="share-url-box">
            <input type="text" class="share-url" id="shareUrl" readonly aria-label="Share URL">
            <button class="copy-btn" id="copyBtn">Copy</button>
          </div>
          <div class="share-info">Share your current timeframe and map position</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Keyboard Shortcuts Overlay -->
  <div class="shortcuts-overlay" id="shortcutsOverlay">
    <div class="shortcuts-content">
      <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
      <div class="shortcut-item">
        <span class="shortcut-desc">Next timeframe</span>
        <span class="shortcut-key">‚Üí</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Previous timeframe</span>
        <span class="shortcut-key">‚Üê</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Play/Pause animation</span>
        <span class="shortcut-key">Space</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Toggle fullscreen</span>
        <span class="shortcut-key">F</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Share current view</span>
        <span class="shortcut-key">S</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Show this help</span>
        <span class="shortcut-key">?</span>
      </div>
      <div class="shortcut-item">
        <span class="shortcut-desc">Close overlay</span>
        <span class="shortcut-key">Esc</span>
      </div>
      <button class="close-shortcuts" id="closeShortcuts">Close</button>
    </div>
  </div>

  <!-- Warning Banner -->
  <div class="warning-overlay" id="warningOverlay">
    <div class="warning-modal">
      <span class="warning-icon">‚ö†Ô∏è</span>
      <p class="warning-text">
        Historical charts only. Do not use for navigation.
      </p>
    </div>
  </div>

  <div id="map"></div>

  <!-- Sources Link -->
  <a href="sources.html" class="sources-link">Sources & Attribution</a>

  <div class="toast" id="toast"></div>

  <div class="ui-layer">
    <div class="controls-card">
      <div class="jog-controls">
        <button class="btn-nav" id="prevBtn" title="Previous Timeframe (‚Üê)" aria-label="Previous timeframe">‚Üê</button>
        <button class="btn-play" id="playBtn" title="Play/Pause (Space)" aria-label="Play or pause animation">‚ñ∂</button>
        <button class="btn-nav" id="nextBtn" title="Next Timeframe (‚Üí)" aria-label="Next timeframe">‚Üí</button>
      </div>

      <div class="speed-control" role="group" aria-label="Animation speed">
        <button class="speed-btn" data-speed="0.5" title="Half speed">¬Ω√ó</button>
        <button class="speed-btn active" data-speed="1" title="Normal speed" aria-pressed="true">1√ó</button>
        <button class="speed-btn" data-speed="2" title="Double speed">2√ó</button>
      </div>

      <div class="loader" id="loader" role="status" aria-label="Loading"></div>

      <div class="timeline-track-wrapper" id="trackWrapper">
        <div class="timeline-track">
          <div class="timeline-progress" id="progress"></div>
          <div id="ticksContainer"></div>
          <div class="handle" id="handle"></div>
        </div>
      </div>

      <div class="info-panel">
        <input type="date" id="timeSelect" class="time-select" aria-label="Select timeframe">
        <div class="label-sub" id="lblRange">Timeline</div>
      </div>
    </div>


  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js" crossorigin></script>
  <script src="https://unpkg.com/pmtiles@3.0.6/dist/pmtiles.js" crossorigin></script>

  <script>
    // Guard against Leaflet tile callbacks firing after a layer was removed
    if (L && L.TileLayer && L.TileLayer.prototype._tileReady) {
      const originalTileReady = L.TileLayer.prototype._tileReady;
      L.TileLayer.prototype._tileReady = function (error, tile) {
        if (!this._map) return;
        return originalTileReady.call(this, error, tile);
      };
    }

    const DeviceInfo = (() => {
      const ua = navigator.userAgent || '';
      const isIOS = /iP(ad|hone|od)/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      const isSafari = /Safari/.test(ua) && !/CriOS|FxiOS|EdgiOS|OPiOS|SamsungBrowser/.test(ua);
      return { isIOS, isMobileSafari: isIOS && isSafari };
    })();

    /** CONFIGURATION **/
    const CONFIG = {
      baseUrl: 'https://data.archive.aero/sectionals/pmtiles/',
      csvUrl: 'dates.csv', // Dynamic Source
      initialView: { center: [32.7767, -96.7970], zoom: 10 },
      ranges: [], // Full list of PMTiles ranges
      frames: [], // Unique timeline dates (start dates)
      dateBounds: { min: null, max: null }
    };

    /** UTILITIES **/
    const Utils = {
      buildPMTilesUrl: (key, customUrl) => {
        if (customUrl) return customUrl;
        return `${CONFIG.baseUrl}${key}.pmtiles`;
      },
      toast: (msg, duration = 3000) => {
        const el = document.getElementById('toast');
        if (el) {
          el.textContent = msg;
          el.classList.add('visible');
          setTimeout(() => el.classList.remove('visible'), duration);
        }
      },
      parseDateRangeKey: (key) => {
        if (!key) return null;
        const parts = key.split('_to_');
        const startStr = parts[0];
        const endStr = parts[1] || parts[0];
        const startDate = new Date(startStr);
        const endDate = new Date(endStr);
        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return null;
        if (endDate < startDate) {
          return {
            startStr: endStr,
            endStr: startStr,
            startDate: endDate,
            endDate: startDate
          };
        }
        return { startStr, endStr, startDate, endDate };
      },
      toIsoDate: (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      },
      formatDateId: (dateStr) => {
        try {
          const [y, m, d] = dateStr.split('-').map(Number);
          const date = new Date(y, m - 1, d);
          return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
        } catch (e) {
          return dateStr;
        }
      },
      toggleFullscreen: () => {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen().catch(err => {
            Utils.toast(`Error entering fullscreen: ${err.message}`);
          });
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          }
        }
      },
      debounce: (func, wait) => {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
    };

    class CompositePMTilesLayer extends L.GridLayer {
      constructor(options = {}) {
        super(options);
        this.sources = [];
        this.sourceVersion = 0;
        this.maxNativeZoom = options.maxNativeZoom ?? 11;
        this.useImageBitmap = options.useImageBitmap ?? ('createImageBitmap' in window);
      }

      setSources(sources) {
        this.sources = sources || [];
        this.sourceVersion += 1;
        this.redraw();
      }

      _normalizeCoords(coords) {
        let z = coords.z;
        let x = coords.x;
        let y = coords.y;
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        if (z > this.maxNativeZoom) {
          const zoomDiff = z - this.maxNativeZoom;
          const divisor = Math.pow(2, zoomDiff);
          offsetX = ((x % divisor) + divisor) % divisor;
          offsetY = ((y % divisor) + divisor) % divisor;
          z = this.maxNativeZoom;
          x = Math.floor(x / divisor);
          y = Math.floor(y / divisor);
          scale = divisor;
        }
        return { z, x, y, scale, offsetX, offsetY };
      }

      async _drawTileData(ctx, data, placement) {
        const blob = new Blob([data], { type: 'image/webp' });
        const sourceSize = 256 / placement.scale;
        const sourceX = placement.offsetX * sourceSize;
        const sourceY = placement.offsetY * sourceSize;

        if (this.useImageBitmap && 'createImageBitmap' in window) {
          const bitmap = await createImageBitmap(blob);
          ctx.drawImage(bitmap, sourceX, sourceY, sourceSize, sourceSize, 0, 0, 256, 256);
          if (bitmap.close) bitmap.close();
          return;
        }

        await new Promise(resolve => {
          const img = new Image();
          const url = URL.createObjectURL(blob);
          img.onload = () => {
            ctx.drawImage(img, sourceX, sourceY, sourceSize, sourceSize, 0, 0, 256, 256);
            URL.revokeObjectURL(url);
            resolve();
          };
          img.onerror = () => {
            URL.revokeObjectURL(url);
            resolve();
          };
          img.src = url;
        });
      }

      createTile(coords, done) {
        const tile = document.createElement('canvas');
        tile.width = 256;
        tile.height = 256;
        const ctx = tile.getContext('2d');
        const version = this.sourceVersion;
        const placement = this._normalizeCoords(coords);
        const { z, x, y } = placement;
        let hasChartData = false;
        const finish = () => {
          tile._hasChartData = hasChartData;
          done(null, tile);
        };

        const render = async () => {
          for (const source of this.sources) {
            if (!this._map || version !== this.sourceVersion) {
              finish();
              return;
            }
            try {
              const result = await source.pmtiles.getZxy(z, x, y);
              if (result && result.data) {
                hasChartData = true;
                await this._drawTileData(ctx, result.data, placement);
              }
            } catch (e) {
              // Ignore missing tiles or fetch errors.
            }
          }
          if (!this._map || version !== this.sourceVersion) {
            finish();
            return;
          }
          finish();
        };

        render();
        return tile;
      }
    }

    /** MENU **/
    const menuToggle = document.getElementById('menuToggle');
    const menuPanel = document.getElementById('siteMenu');
    const menuTrigger = document.querySelector('.menu-trigger');
    const toolsControl = document.getElementById('toolsControl');
    const toolsBtn = document.getElementById('toolsBtn');

    if (menuToggle && menuPanel && menuTrigger) {
      const closeMenu = () => {
        menuTrigger.classList.remove('open');
        menuToggle.setAttribute('aria-expanded', 'false');
      };

      menuToggle.addEventListener('click', (event) => {
        event.stopPropagation();
        if (toolsControl?.classList.contains('open')) {
          toolsControl.classList.remove('open');
          toolsBtn?.setAttribute('aria-expanded', 'false');
        }
        const isOpen = menuTrigger.classList.toggle('open');
        menuToggle.setAttribute('aria-expanded', String(isOpen));
      });

      menuPanel.querySelectorAll('a').forEach((item) => {
        item.addEventListener('click', () => {
          closeMenu();
        });
      });

      document.addEventListener('click', (event) => {
        if (!menuTrigger.contains(event.target)) {
          closeMenu();
        }
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          closeMenu();
        }
      });
    }

    /** COLLAPSIBLE SECTIONS **/
    const initCollapsibleSections = () => {
      document.querySelectorAll('.section-header').forEach(header => {
        const section = header.parentElement;
        const content = header.nextElementSibling;
        const icon = header.querySelector('.collapse-icon');
        if (!content) return;

        const setExpandedState = (isExpanded) => {
          if (isExpanded) {
            section.classList.remove('collapsed');
            if (icon) icon.textContent = '‚ñº';
            content.style.paddingTop = '';
            content.style.maxHeight = content.scrollHeight + 'px';
            requestAnimationFrame(() => {
              content.style.transform = 'scaleY(1)';
              content.style.opacity = '1';
            });
          } else {
            section.classList.add('collapsed');
            if (icon) icon.textContent = '‚ñ∂';
            content.style.transform = 'scaleY(0)';
            content.style.opacity = '0';
            const onEnd = (event) => {
              if (event.propertyName !== 'transform') return;
              content.style.maxHeight = '0px';
              content.style.paddingTop = '0px';
              content.removeEventListener('transitionend', onEnd);
            };
            content.addEventListener('transitionend', onEnd);
          }
        };

        if (section.classList.contains('collapsed')) {
          content.style.maxHeight = '0px';
          content.style.paddingTop = '0px';
          content.style.transform = 'scaleY(0)';
          content.style.opacity = '0';
          if (icon) icon.textContent = '‚ñ∂';
        } else {
          content.style.maxHeight = content.scrollHeight + 'px';
          content.style.transform = 'scaleY(1)';
          content.style.opacity = '1';
          if (icon) icon.textContent = '‚ñº';
        }

        header.addEventListener('click', () => {
          const isExpanded = !section.classList.contains('collapsed');
          setExpandedState(!isExpanded);
        });
      });
    };

    // Initialize after DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initCollapsibleSections);
    } else {
      initCollapsibleSections();
    }

    /** DATA LOADER **/
    async function loadData() {
      return new Promise((resolve, reject) => {
        Papa.parse(CONFIG.csvUrl, {
          download: true,
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            try {
              const ranges = [];
              results.data.forEach(row => {
                const key = (row.date_iso || '').trim();
                if (!key || key === '?') return;
                const parsed = Utils.parseDateRangeKey(key);
                if (!parsed) return;
                ranges.push({
                  key,
                  start: parsed.startStr,
                  end: parsed.endStr,
                  startDate: parsed.startDate,
                  endDate: parsed.endDate,
                  startTime: parsed.startDate.getTime(),
                  endTime: parsed.endDate.getTime(),
                  url: row.url || null
                });
              });
              CONFIG.ranges = ranges.sort((a, b) => {
                return a.startTime - b.startTime || a.endTime - b.endTime;
              });

              const uniqueStartDates = Array.from(new Set(CONFIG.ranges.map(r => r.start)));
              CONFIG.frames = uniqueStartDates.sort().map(date => ({
                id: Utils.formatDateId(date),
                date
              }));

              if (CONFIG.ranges.length > 0) {
                let minStart = CONFIG.ranges[0];
                let maxEnd = CONFIG.ranges[0];
                CONFIG.ranges.forEach(range => {
                  if (range.startTime < minStart.startTime) minStart = range;
                  if (range.endTime > maxEnd.endTime) maxEnd = range;
                });
                CONFIG.dateBounds.min = Utils.toIsoDate(minStart.startDate);
                CONFIG.dateBounds.max = Utils.toIsoDate(maxEnd.endDate);
              }
              resolve();
            } catch (e) {
              console.error("Data processing error", e);
              Utils.toast("Error processing CSV data");
              reject(e);
            }
          },
          error: (err) => {
            console.error("CSV Load Error", err);
            Utils.toast("Failed to load timeline data");
            reject(err);
          }
        });
      });
    }

    /** MAP CONTROLLER **/
    class MapController {
      constructor(mapId) {
        this.map = L.map(mapId, {
          zoomControl: false,
          fadeAnimation: true,
          zoomAnimation: true,
          attributionControl: true,
          zoomSnap: 1,
          zoomDelta: 1,
          wheelPxPerZoomLevel: 120
        }).setView(CONFIG.initialView.center, CONFIG.initialView.zoom);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 14, maxNativeZoom: 14, opacity: 1, zIndex: 1,
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &middot; &copy; <a href="https://carto.com/attributions">CARTO</a>'
        }).addTo(this.map);

        L.control.zoom({ position: 'topright' }).addTo(this.map);

        this.activeLayers = [];
        this.pmtilesInstances = {}; // Cache for PMTiles instances
        this.pmtilesAccess = {};
        this.pmtilesAccessSeq = 0;
        this.pmtilesCacheLimit = DeviceInfo.isMobileSafari ? 10 : 20;
        this.activeKeys = [];
        this.frameRequestToken = 0;
        this.overlayOpacity = 1;
        this.activeCompositeIndex = 0;
        this.compositeLayers = [];

        const layerOptions = {
          minZoom: 0,
          maxZoom: 14,
          minNativeZoom: 0,
          maxNativeZoom: 11,
          tileSize: 256,
          opacity: 0,
          keepBuffer: 1,
          updateWhenIdle: true,
          updateWhenZooming: false,
          zIndex: 10,
          useImageBitmap: !DeviceInfo.isMobileSafari
        };

        // Keep one layer visible while the next date's layer preloads.
        for (let i = 0; i < 2; i++) {
          const layer = new CompositePMTilesLayer(layerOptions);
          layer.setOpacity(0);
          layer.addTo(this.map);
          this.compositeLayers.push(layer);
        }
        this.compositeLayer = this.compositeLayers[this.activeCompositeIndex];
        this.activeLayers = [this.compositeLayer];

        // Debounced version of showFrame for timeline scrubbing
        const debounceDelay = 350;
        this.showFrameDebounced = Utils.debounce(this.showFrame.bind(this), debounceDelay);
      }

      getPMTilesInstance(key, customUrl) {
        let pmtilesSource = this.pmtilesInstances[key];
        if (!pmtilesSource) {
          const pmtilesUrl = Utils.buildPMTilesUrl(key, customUrl);
          pmtilesSource = new pmtiles.PMTiles(pmtilesUrl);
          this.pmtilesInstances[key] = pmtilesSource;
        }
        this.pmtilesAccessSeq += 1;
        this.pmtilesAccess[key] = this.pmtilesAccessSeq;
        return pmtilesSource;
      }

      prunePMTilesInstances(activeKeys = []) {
        const keys = Object.keys(this.pmtilesInstances);
        if (keys.length <= this.pmtilesCacheLimit) return;

        const protectedKeys = new Set(activeKeys);
        const evictable = keys
          .filter(key => !protectedKeys.has(key))
          .sort((a, b) => (this.pmtilesAccess[a] || 0) - (this.pmtilesAccess[b] || 0));

        while (Object.keys(this.pmtilesInstances).length > this.pmtilesCacheLimit && evictable.length) {
          const key = evictable.shift();
          delete this.pmtilesInstances[key];
          delete this.pmtilesAccess[key];
        }
      }

      layerHasChartData(layer) {
        if (!layer || !layer._tiles) return false;
        const tileEntries = Object.values(layer._tiles);
        return tileEntries.some(entry => entry?.el?._hasChartData === true);
      }

      waitForLayerReady(layer, timeoutMs = 3200) {
        return new Promise(resolve => {
          let settled = false;
          const finish = (isReady) => {
            if (settled) return;
            settled = true;
            layer.off('load', onTileEvent);
            layer.off('tileload', onTileEvent);
            clearInterval(poll);
            clearTimeout(timeout);
            resolve(isReady);
          };
          const checkReady = () => {
            if (this.layerHasChartData(layer)) {
              finish(true);
            }
          };
          const onTileEvent = () => checkReady();
          const poll = setInterval(checkReady, 120);
          const timeout = setTimeout(() => finish(this.layerHasChartData(layer)), timeoutMs);
          layer.on('load', onTileEvent);
          layer.on('tileload', onTileEvent);
          checkReady();
        });
      }

      async showFrame(selectedDateStr) {
        const loader = document.getElementById('loader');
        const spinnerTimeout = setTimeout(() => loader.classList.add('active'), 100);
        try {
          const selectedDate = new Date(selectedDateStr);
          const selectedTime = selectedDate.getTime();
          if (isNaN(selectedTime)) return;

          const rangesInEffect = CONFIG.ranges.filter(range => {
            return selectedTime >= range.startTime && selectedTime < range.endTime;
          });

          if (rangesInEffect.length === 0) {
            Utils.toast('No charts available for selected date');
            return;
          }

          rangesInEffect.sort((a, b) => a.startTime - b.startTime || a.endTime - b.endTime);
          const opacityValue = parseFloat(document.getElementById('toolOpacitySlider')?.value || 100) / 100;
          const activeKeys = rangesInEffect.map(range => range.key);

          const sameKeys = this.activeKeys.length === activeKeys.length
            && this.activeKeys.every((key, idx) => key === activeKeys[idx]);
          if (sameKeys) {
            this.overlayOpacity = opacityValue;
            this.compositeLayers[this.activeCompositeIndex].setOpacity(opacityValue);
            return;
          }

          const sources = rangesInEffect.map(range => {
            const pmtilesSource = this.getPMTilesInstance(range.key, range.url);
            return { key: range.key, pmtiles: pmtilesSource };
          });

          const requestToken = ++this.frameRequestToken;
          const nextIndex = this.activeCompositeIndex === 0 ? 1 : 0;
          const nextLayer = this.compositeLayers[nextIndex];
          const activeLayer = this.compositeLayers[this.activeCompositeIndex];

          nextLayer.setOpacity(0);
          nextLayer.setSources(sources);
          const nextLayerReady = await this.waitForLayerReady(nextLayer, 3200);
          if (requestToken !== this.frameRequestToken) return;
          if (!nextLayerReady && this.layerHasChartData(activeLayer)) {
            // Keep the previous layer visible instead of exposing the basemap.
            nextLayer.setOpacity(0);
            return;
          }

          this.overlayOpacity = opacityValue;
          nextLayer.bringToFront();
          nextLayer.setOpacity(opacityValue);
          requestAnimationFrame(() => {
            if (requestToken !== this.frameRequestToken) return;
            activeLayer.setOpacity(0);
          });
          this.activeCompositeIndex = nextIndex;
          this.compositeLayer = nextLayer;
          this.activeLayers = [this.compositeLayer];
          this.activeKeys = activeKeys;
          this.prunePMTilesInstances(activeKeys);

          // Update effective layers count in chart info
          const chartInfoEffective = document.getElementById('chartInfoEffective');
          if (chartInfoEffective) {
            chartInfoEffective.textContent = sources.length.toString();
          }
        } finally {
          clearTimeout(spinnerTimeout);
          loader.classList.remove('active');
        }
      }

      setOpacity(opacity) {
        this.overlayOpacity = opacity;
        const activeLayer = this.compositeLayers[this.activeCompositeIndex];
        if (activeLayer) {
          activeLayer.setOpacity(opacity);
        }
      }
    }

    /** TIMELINE CONTROLLER **/
    class TimelineApp {
      constructor(mapController) {
        this.mapCtrl = mapController;
        this.frames = CONFIG.frames;

        const dates = this.frames.map(f => new Date(f.date).getTime());
        const min = Math.min(...dates);
        const max = Math.max(...dates);
        this.frames.forEach((f, i) => { const d = dates[i]; f.pct = max === min ? 0 : ((d - min) / (max - min)) * 100; });

        this.currentIndex = 0;
        this.selectedDate = null;
        this.activeTickIndex = null;
        this.frameTimes = dates;
        this.isPlaying = false;
        this.playInterval = null;
        this.playbackSpeed = 1;

        this.ui = {
          prevBtn: document.getElementById('prevBtn'),
          nextBtn: document.getElementById('nextBtn'),
          playBtn: document.getElementById('playBtn'),
          progress: document.getElementById('progress'),
          handle: document.getElementById('handle'),
          track: document.getElementById('trackWrapper'),
          timeSelect: document.getElementById('timeSelect'),
          lblRange: document.getElementById('lblRange'),
          ticks: document.getElementById('ticksContainer')
        };

        this.tickElements = [];

        this.initUI();
        this.initControls();
        const initialDate = this.ui.timeSelect?.value || this.frames[this.frames.length - 1]?.date;
        if (initialDate) {
          this.updateByDate(initialDate);
        }

        window.addEventListener('keydown', (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

          if (e.key === 'ArrowRight') this.step(1);
          if (e.key === 'ArrowLeft') this.step(-1);
          if (e.key === ' ') {
            e.preventDefault();
            this.togglePlay();
          }
          if (e.key === 'f' || e.key === 'F') {
            e.preventDefault();
            Utils.toggleFullscreen();
          }
          if (e.key === 's' || e.key === 'S') {
            e.preventDefault();
            this.openToolsPanel('share');
          }
          if (e.key === '?') {
            e.preventDefault();
            document.getElementById('shortcutsOverlay').classList.add('visible');
            this.hideAllPanels(['shortcutsOverlay']);
          }
          if (e.key === 'Escape') {
            document.getElementById('shortcutsOverlay').classList.remove('visible');
            this.hideAllPanels();
          }
        });
      }

      initControls() {
        // Help button
        document.getElementById('helpBtn')?.addEventListener('click', () => {
          document.getElementById('shortcutsOverlay').classList.add('visible');
          this.hideAllPanels(['shortcutsOverlay']);
        });

        document.getElementById('closeShortcuts')?.addEventListener('click', () => {
          document.getElementById('shortcutsOverlay').classList.remove('visible');
        });

        document.getElementById('shortcutsOverlay')?.addEventListener('click', (e) => {
          if (e.target.id === 'shortcutsOverlay') {
            document.getElementById('shortcutsOverlay').classList.remove('visible');
          }
        });

        // Fullscreen button
        document.getElementById('fullscreenBtn')?.addEventListener('click', () => {
          Utils.toggleFullscreen();
        });

        // Tools Dropdown
        const toolsControl = document.getElementById('toolsControl');
        const toolsBtn = document.getElementById('toolsBtn');
        const toolOpacitySlider = document.getElementById('toolOpacitySlider');
        const toolOpacityValue = document.getElementById('toolOpacityValue');

        toolsBtn?.addEventListener('click', (event) => {
          event.stopPropagation();
          if (toolsControl?.classList.contains('open')) {
            this.closeToolsPanel();
          } else {
            this.openToolsPanel();
          }
        });

        toolsControl?.addEventListener('click', (event) => {
          event.stopPropagation();
        });

        document.addEventListener('click', (event) => {
          if (toolsControl && !toolsControl.contains(event.target)) {
            this.closeToolsPanel();
          }
        });

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            this.closeToolsPanel();
          }
        });

        toolOpacitySlider?.addEventListener('input', (e) => {
          const value = e.target.value;
          toolOpacityValue.textContent = value;
          this.mapCtrl.setOpacity(value / 100);
        });

        const shareUrl = document.getElementById('shareUrl');
        const copyBtn = document.getElementById('copyBtn');

        copyBtn?.addEventListener('click', async () => {
          try {
            this.updateShareUrl();
            await navigator.clipboard.writeText(shareUrl.value);
            copyBtn.textContent = '‚úì Copied';
            copyBtn.classList.add('copied');
            setTimeout(() => {
              copyBtn.textContent = 'Copy';
              copyBtn.classList.remove('copied');
            }, 2000);
          } catch (err) {
            // Fallback for browsers without clipboard API support
            try {
              shareUrl.select();
              shareUrl.setSelectionRange(0, 99999); // For mobile devices
              const success = document.execCommand('copy');
              if (success) {
                copyBtn.textContent = '‚úì Copied';
                copyBtn.classList.add('copied');
                setTimeout(() => {
                  copyBtn.textContent = 'Copy';
                  copyBtn.classList.remove('copied');
                }, 2000);
              } else {
                Utils.toast('Please manually copy the URL');
              }
            } catch (fallbackErr) {
              Utils.toast('Please manually copy the URL');
            }
          }
        });

        // Play button
        this.ui.playBtn?.addEventListener('click', () => {
          this.togglePlay();
        });

        // Speed Control
        const speedBtns = document.querySelectorAll('.speed-btn');
        speedBtns.forEach(btn => {
          btn.addEventListener('click', () => {
            const speed = parseFloat(btn.dataset.speed);
            this.playbackSpeed = speed;

            // Update active state and aria-pressed
            speedBtns.forEach(b => {
              b.classList.remove('active');
              b.setAttribute('aria-pressed', 'false');
            });
            btn.classList.add('active');
            btn.setAttribute('aria-pressed', 'true');

            // Update interval if playing
            if (this.isPlaying && this.playInterval) {
              clearInterval(this.playInterval);
              this.playInterval = setInterval(() => {
                this.step(1);
              }, 2000 / this.playbackSpeed);
            }
          });
        });

      }

      hideAllPanels(except = []) {
        if (!except.includes('toolsPanel')) {
          this.closeToolsPanel();
        }
      }

      openToolsPanel(focusTarget) {
        const toolsControl = document.getElementById('toolsControl');
        const toolsBtn = document.getElementById('toolsBtn');
        if (!toolsControl || !toolsBtn) return;
        const menuTrigger = document.querySelector('.menu-trigger');
        const menuToggle = document.getElementById('menuToggle');
        if (menuTrigger?.classList.contains('open')) {
          menuTrigger.classList.remove('open');
          menuToggle?.setAttribute('aria-expanded', 'false');
        }
        toolsControl.classList.add('open');
        toolsBtn.setAttribute('aria-expanded', 'true');
        this.updateShareUrl();

        // Recalculate section heights when panel opens
        setTimeout(() => {
          document.querySelectorAll('.section-content').forEach(content => {
            const section = content.parentElement;
            if (!section.classList.contains('collapsed')) {
              content.style.paddingTop = '';
              content.style.maxHeight = content.scrollHeight + 'px';
              content.style.transform = 'scaleY(1)';
              content.style.opacity = '1';
            }
          });
        }, 50);

        if (focusTarget === 'share') {
          document.getElementById('shareUrl')?.focus();
        }
      }

      closeToolsPanel() {
        const toolsControl = document.getElementById('toolsControl');
        const toolsBtn = document.getElementById('toolsBtn');
        toolsControl?.classList.remove('open');
        toolsBtn?.setAttribute('aria-expanded', 'false');
      }

      updateShareUrl() {
        const selectedDate = this.selectedDate || this.frames[this.currentIndex]?.date;
        const center = this.mapCtrl.map.getCenter();
        const zoom = this.mapCtrl.map.getZoom();
        const url = `${window.location.origin}${window.location.pathname}?date=${selectedDate}&lat=${center.lat.toFixed(4)}&lng=${center.lng.toFixed(4)}&zoom=${zoom}`;
        document.getElementById('shareUrl').value = url;
      }

      togglePlay() {
        this.isPlaying = !this.isPlaying;
        const playBtn = this.ui.playBtn;

        if (this.isPlaying) {
          playBtn.textContent = '‚è∏';
          playBtn.title = 'Pause (Space)';
          playBtn.setAttribute('aria-label', 'Pause animation');
          this.playInterval = setInterval(() => {
            this.step(1);
          }, 2000 / this.playbackSpeed);
        } else {
          playBtn.textContent = '‚ñ∂';
          playBtn.title = 'Play (Space)';
          playBtn.setAttribute('aria-label', 'Play animation');
          if (this.playInterval) {
            clearInterval(this.playInterval);
            this.playInterval = null;
          }
        }
      }

      initUI() {
        if (!this.frames.length) return;

        this.ui.lblRange.textContent = `${this.frames[0].id} ‚Äî ${this.frames[this.frames.length - 1].id}`;

        // Setup date picker with min/max and default to most recent
        const firstDate = CONFIG.dateBounds.min || this.frames[0].date;
        const lastDate = CONFIG.dateBounds.max || this.frames[this.frames.length - 1].date;
        this.ui.timeSelect.min = firstDate;
        this.ui.timeSelect.max = lastDate;
        this.ui.timeSelect.value = lastDate; // Default to most recent
        this.selectedDate = lastDate;

        // Start at most recent frame
        this.currentIndex = this.frames.length - 1;

        this.ui.timeSelect.addEventListener('change', () => {
          const selectedDate = this.ui.timeSelect.value;
          if (!selectedDate) return;
          this.updateByDate(selectedDate);
        });

        // ticks with year labels
        const years = new Set();
        this.frames.forEach((f, i) => {
          const tick = document.createElement('div');
          tick.className = 'tick';
          tick.style.left = `${f.pct}%`;

          // Extract year from date
          const year = f.date.split('-')[0];

          // Mark as major tick if it's a new year or every 5th year
          if (!years.has(year)) {
            years.add(year);
            const yearNum = parseInt(year);
            if (yearNum % 5 === 0 || i === 0 || i === this.frames.length - 1) {
              tick.classList.add('major');
              const label = document.createElement('div');
              label.className = 'tick-label';
              label.textContent = year;
              tick.appendChild(label);
            }
          }

          this.ui.ticks.appendChild(tick);
          this.tickElements.push(tick);
        });

        // Jog Controls
        this.ui.prevBtn.onclick = () => this.step(-1);
        this.ui.nextBtn.onclick = () => this.step(1);

        // drag on the track/handle
        let trackRect = null;
        let rafPending = false;
        let lastClientX = 0;

        const updateTrackRect = () => {
          trackRect = this.ui.track.getBoundingClientRect();
        };

        const handleInput = (clientX) => {
          if (!trackRect) updateTrackRect();
          const x = Math.max(0, Math.min(clientX - trackRect.left, trackRect.width));
          const pct = (x / trackRect.width) * 100;
          const closestIdx = this.findClosestFrameIndexByPct(pct);

          if (closestIdx !== this.currentIndex) this.update(closestIdx, true);
        };

        let isDragging = false;
        const scheduleInput = (clientX) => {
          lastClientX = clientX;
          if (rafPending) return;
          rafPending = true;
          requestAnimationFrame(() => {
            rafPending = false;
            handleInput(lastClientX);
          });
        };

        const startDrag = (e) => {
          isDragging = true;
          updateTrackRect();
          scheduleInput((e.touches?.[0]?.clientX) ?? e.clientX);
        };
        const moveDrag = (e) => { if (isDragging) scheduleInput((e.touches?.[0]?.clientX) ?? e.clientX); };
        const endDrag = () => { isDragging = false; rafPending = false; };

        this.ui.track.addEventListener('mousedown', startDrag);
        this.ui.track.addEventListener('touchstart', startDrag, { passive: false });
        window.addEventListener('mousemove', moveDrag);
        window.addEventListener('touchmove', moveDrag, { passive: false });
        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);
        window.addEventListener('resize', () => { trackRect = null; });
      }

      findClosestFrameIndexByPct(pct) {
        const n = this.frames.length;
        if (n === 0) return 0;
        if (pct <= this.frames[0].pct) return 0;
        if (pct >= this.frames[n - 1].pct) return n - 1;

        let lo = 0;
        let hi = n - 1;
        while (lo < hi) {
          const mid = (lo + hi) >> 1;
          if (this.frames[mid].pct < pct) {
            lo = mid + 1;
          } else {
            hi = mid;
          }
        }

        const right = lo;
        const left = Math.max(0, right - 1);
        return (Math.abs(this.frames[right].pct - pct) < Math.abs(this.frames[left].pct - pct)) ? right : left;
      }

      findFrameIndexByDate(selectedTime) {
        let lo = 0;
        let hi = this.frameTimes.length - 1;
        let bestIdx = 0;

        while (lo <= hi) {
          const mid = (lo + hi) >> 1;
          const frameTime = this.frameTimes[mid];
          if (frameTime <= selectedTime) {
            bestIdx = mid;
            lo = mid + 1;
          } else {
            hi = mid - 1;
          }
        }

        return bestIdx;
      }

      updateByDate(dateStr, lazy = false) {
        const selectedTime = new Date(dateStr).getTime();
        if (isNaN(selectedTime)) return;

        const bestIdx = this.findFrameIndexByDate(selectedTime);
        this.update(bestIdx, lazy, dateStr);
      }

      update(index, lazy = false, selectedDateOverride = null) {
        this.currentIndex = index;
        const f = this.frames[index];
        const selectedDate = selectedDateOverride || f.date;
        this.selectedDate = selectedDate;

        // Update date picker to show the selected date
        if (this.ui.timeSelect && this.ui.timeSelect.value !== selectedDate) {
          this.ui.timeSelect.value = selectedDate;
        }

        this.ui.handle.style.left = `${f.pct}%`;
        this.ui.progress.style.width = `${f.pct}%`;

        if (this.activeTickIndex !== null && this.tickElements[this.activeTickIndex]) {
          this.tickElements[this.activeTickIndex].classList.remove('active');
        }
        if (this.tickElements[index]) {
          this.tickElements[index].classList.add('active');
        }
        this.activeTickIndex = index;

        if (lazy) {
          this.mapCtrl.showFrameDebounced(selectedDate);
        } else {
          this.mapCtrl.showFrame(selectedDate);
        }
      }

      step(dir) {
        let next = this.currentIndex + dir;
        if (next >= this.frames.length) next = 0;
        if (next < 0) next = this.frames.length - 1;
        this.update(next);
      }
    }

    // Initialize Application
    async function initApp() {
      // Loading progress elements
      const loadingSplash = document.getElementById('loadingSplash');
      const loadingProgressBar = document.getElementById('loadingProgressBar');
      const loadingStatus = document.getElementById('loadingStatus');

      const updateLoading = (percent, status) => {
        loadingProgressBar.style.width = `${percent}%`;
        loadingStatus.textContent = status;
      };

      updateLoading(10, 'Loading timeline data...');

      // Show warning banner temporarily
      const warningOverlay = document.getElementById('warningOverlay');
      setTimeout(() => warningOverlay.classList.add('visible'), 1500);
      setTimeout(() => warningOverlay.classList.remove('visible'), 8000);

      await loadData(); // Fetch and parse CSV first
      updateLoading(40, 'Initializing map...');

      if (CONFIG.frames.length === 0) {
        Utils.toast("No valid frames found in CSV");
        loadingSplash.classList.add('hidden');
        return;
      }

      const mapCtrl = new MapController('map');
      const zoomState = { count: 0, timeout: null };
      const setZooming = (isZooming) => {
        if (isZooming) {
          zoomState.count += 1;
          if (zoomState.timeout) {
            clearTimeout(zoomState.timeout);
            zoomState.timeout = null;
          }
          document.body.classList.add('zooming');
          return;
        }
        zoomState.count = Math.max(0, zoomState.count - 1);
        if (zoomState.count === 0) {
          zoomState.timeout = setTimeout(() => {
            document.body.classList.remove('zooming');
            zoomState.timeout = null;
          }, 120);
        }
      };
      const attachZoomListeners = (map) => {
        map.on('zoomstart', () => setZooming(true));
        map.on('zoomend', () => setZooming(false));
      };
      attachZoomListeners(mapCtrl.map);
      const toolsControl = document.getElementById('toolsControl');
      const mapControls = mapCtrl.map.getContainer().querySelector('.leaflet-top.leaflet-right');
      if (toolsControl && mapControls) {
        mapControls.prepend(toolsControl);
        if (window.L && L.DomEvent) {
          L.DomEvent.disableClickPropagation(toolsControl);
          L.DomEvent.disableScrollPropagation(toolsControl);
        }
      }
      updateLoading(70, 'Loading controls...');

      const timelineApp = new TimelineApp(mapCtrl);
      updateLoading(90, 'Almost ready...');

      // Handle URL parameters for shared links
      const urlParams = new URLSearchParams(window.location.search);
      const dateParam = urlParams.get('date');
      const latParam = urlParams.get('lat');
      const lngParam = urlParams.get('lng');
      const zoomParam = urlParams.get('zoom');

      // Set map position from URL if available
      if (latParam && lngParam && zoomParam) {
        const lat = parseFloat(latParam);
        const lng = parseFloat(lngParam);
        const zoom = parseInt(zoomParam);
        if (!isNaN(lat) && !isNaN(lng) && !isNaN(zoom)) {
          mapCtrl.map.setView([lat, lng], zoom);
        }
      }

      // Set timeframe from URL if available
      if (dateParam) {
        timelineApp.updateByDate(dateParam);
      }

      // Location Crosshair Button - Request User's Geolocation
      const locateBtn = document.getElementById('locateBtn');
      locateBtn?.addEventListener('click', () => {
        if ('geolocation' in navigator) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              const lat = position.coords.latitude;
              const lng = position.coords.longitude;
              mapCtrl.map.flyTo([lat, lng], 10, { duration: 1.5 });
              Utils.toast('Centered on your location (GPS)');
            },
            (error) => {
              console.log('GPS failed, trying IP geolocation...');
              // Fallback to IP Geolocation
              fetch('https://get.geojs.io/v1/ip/geo.json')
                .then(response => response.json())
                .then(data => {
                  const lat = parseFloat(data.latitude);
                  const lng = parseFloat(data.longitude);
                  mapCtrl.map.flyTo([lat, lng], 10, { duration: 1.5 });
                })
                .catch(err => {
                  console.error('IP Geolocation error:', err);
                  Utils.toast('Unable to determine location');
                });
            },
            {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 0
            }
          );
        } else {
          Utils.toast('Geolocation not supported by your browser');
        }
      });

      // Update chart info panel with initial data
      const chartInfoDate = document.getElementById('chartInfoDate');
      const chartInfoTotal = document.getElementById('chartInfoTotal');
      const chartInfoZoom = document.getElementById('chartInfoZoom');
      chartInfoTotal.textContent = CONFIG.ranges.length.toString();

      // Update zoom level display
      const updateZoomDisplay = () => {
        if (chartInfoZoom) {
          chartInfoZoom.textContent = mapCtrl.map.getZoom().toFixed(2);
        }
      };
      mapCtrl.map.on('zoomend', updateZoomDisplay);
      updateZoomDisplay(); // Initial value

      // Update chart info when frame changes
      const originalUpdate = timelineApp.update.bind(timelineApp);
      timelineApp.update = function (index, lazy, selectedDateOverride) {
        originalUpdate(index, lazy, selectedDateOverride);
        const displayDate = this.selectedDate || this.frames[index]?.date;
        if (chartInfoDate && displayDate) {
          chartInfoDate.textContent = Utils.formatDateId(displayDate);
        }
      };
      const initialDisplayDate = timelineApp.selectedDate || timelineApp.frames[timelineApp.currentIndex]?.date;
      if (chartInfoDate && initialDisplayDate) {
        chartInfoDate.textContent = Utils.formatDateId(initialDisplayDate);
      }

      // Hide loading splash
      updateLoading(100, 'Ready!');
      setTimeout(() => {
        loadingSplash.classList.add('hidden');
      }, 300);

      // Initial IP Geolocation (Non-precise, privacy friendly)
      // Only runs if no location params provided in URL
      if (!latParam || !lngParam) {
        fetch('https://get.geojs.io/v1/ip/geo.json')
          .then(response => response.json())
          .then(data => {
            const lat = parseFloat(data.latitude);
            const lng = parseFloat(data.longitude);
            if (!isNaN(lat) && !isNaN(lng)) {
              mapCtrl.map.flyTo([lat, lng], 10, { duration: 1.5 });
            }
          })
          .catch(e => console.log('Auto-geolocation failed', e)); // Silent fail
      }
    }

    document.addEventListener('DOMContentLoaded', initApp);
  </script>

  <!-- Privacy-friendly analytics by Plausible -->
  <script async src="https://plausible.io/js/pa-m9DzDEgB7Ebb2zKdbBaMF.js"></script>
  <script>
    window.plausible = window.plausible || function () { (plausible.q = plausible.q || []).push(arguments) }, plausible.init = plausible.init || function (i) { plausible.o = i || {} };
    plausible.init()
  </script>
</body>

</html>
